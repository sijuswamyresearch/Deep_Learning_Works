{
  "hash": "02a45245b9bfd78fa533311562e3bed2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Assignment 1- Foundations of Deep Learning for Visual recognition\n---\n\ntitle: \"Assignment 1- Foundations of Deep Learning for Visual Recognition\"\njupyter: python3\n---\n\n\n# Evaluation 1\n\n## Design of a Deep Convolutional Neural Network\n\n>**Problem Statement**\n\nDesign the deep convolutional neural network based on user input. Compute the number of learnable parameters in each layer. The design of the architecture and the number of learnable parameters must be printed. Comments are required for the understandability of the logic behind the code. Convolution layer computation can be written as a function file. Direct functions available as built-in library packages must not be used.\n\n\n>**Goal**:\n\nThis task is to design a deep convolutional neural network (CNN) from scratch based on user input, compute the number of learnable parameters in each layer, and provide a detailed summary of the network architecture. This task aims to enhance understanding of CNN architecture and parameter computation without relying on built-in library functions.\n\n>**Objectives:**\n\n1. *Design a CNN Architecture*: Create a flexible and user-friendly interface for designing a CNN architecture using an object-oriented programming (OOP) approach, mimicking the Keras Sequential API.\n2. *Compute Learnable Parameters*: Implement functions to compute the number of learnable parameters in each layer of the CNN, including convolutional layers, fully connected layers, dropout layers, flatten layers, and max pooling layers.\n3. *Provide Detailed Summary*: Generate a detailed summary of the CNN architecture, including the number of learnable parameters for each layer and the total number of learnable parameters.\n4. *Ensure Understandability*: Include comprehensive comments and documentation to ensure the code is understandable and maintainable.\n\n>**Deliverables**:\n\n1. *CNNModel Class*: A class representing the entire CNN model, allowing the addition of various layers and providing a summary of the model.\n2. *Layer Classes*: Individual classes for different types of layers, including Conv2D, Dense, Dropout, Flatten, and MaxPooling2D, each with methods to compute the number of learnable parameters.\n3. *User-Friendly API*: An interface that allows users to add layers to the model using a simple and intuitive API, similar to the Keras Sequential API.\n4. *Model Summary*: A function to print a detailed summary of the CNN architecture, including the number of learnable parameters for each layer and the total number of learnable parameters.\n5. *Documentation and Comments*: Comprehensive comments and documentation to explain the logic behind the code and ensure it is understandable and maintainable.\n\n### Model architecture\n\n\n\n```{mermaid}\nclassDiagram\n    class Layer {\n        +input_shape: None\n        +output_shape: None\n        +params: 0\n        +compute_output_shape(input_shape)\n        +compute_params()\n    }\n\n    class Conv2D {\n        +filters: int\n        +kernel_size: tuple\n        +activation: str\n        +strides: tuple\n        +padding: str\n        +bias: bool\n        +compute_output_shape(input_shape)\n        +compute_params()\n    }\n\n    class Dense {\n        +neurons: int\n        +activation: str\n        +bias: bool\n        +compute_output_shape(input_shape)\n        +compute_params()\n    }\n\n    class Dropout {\n        +rate: float\n        +compute_output_shape(input_shape)\n    }\n\n    class Flatten {\n        +compute_output_shape(input_shape)\n    }\n\n    class MaxPooling2D {\n        +pool_size: tuple\n        +strides: tuple\n        +padding: str\n        +compute_output_shape(input_shape)\n    }\n\n    class CNNModel {\n        +layers: list\n        +input_shape: None\n        +add(layer)\n        +summary()\n    }\n\n    Layer <|-- Conv2D\n    Layer <|-- Dense\n    Layer <|-- Dropout\n    Layer <|-- Flatten\n    Layer <|-- MaxPooling2D\n    CNNModel --> Layer\n```\n\n\n### Model\n\n::: {#83ba8230 .cell execution_count=1}\n``` {.python .cell-code}\nclass Layer:\n    def __init__(self):\n        self.input_shape = None\n        self.output_shape = None\n        self.params = 0\n\n    def compute_output_shape(self, input_shape):\n        raise NotImplementedError\n\n    def compute_params(self):\n        raise NotImplementedError\n\nclass Conv2D(Layer):\n    def __init__(self, filters, kernel_size, activation=None, input_shape=None, strides=(1, 1), padding='valid', bias=True):\n        super().__init__()\n        self.filters = filters\n        self.kernel_size = kernel_size\n        self.activation = activation\n        self.strides = strides\n        self.padding = padding\n        self.bias = bias\n        self.input_shape = input_shape\n        if input_shape is not None:\n            self.params = self.compute_params()\n\n    def compute_params(self):\n        input_channels = self.input_shape[-1]\n        params = (input_channels * self.filters * self.kernel_size[0] * self.kernel_size[1])\n        if self.bias:\n            params += self.filters\n        return params\n\n    def compute_output_shape(self, input_shape):\n        if self.padding == 'same':\n            output_height = input_shape[0] // self.strides[0]\n            output_width = input_shape[1] // self.strides[1]\n        else:\n            output_height = (input_shape[0] - self.kernel_size[0]) // self.strides[0] + 1\n            output_width = (input_shape[1] - self.kernel_size[1]) // self.strides[1] + 1\n        return (output_height, output_width, self.filters)\n\n    def __str__(self):\n        return (f\"Conv2D Layer: {self.params} parameters, \"\n                f\"filters: {self.filters}, \"\n                f\"Kernel Size: {self.kernel_size}, Activation: {self.activation}\")\n\nclass Dense(Layer):\n    def __init__(self, neurons, activation=None, bias=True):\n        super().__init__()\n        self.neurons = neurons\n        self.activation = activation\n        self.bias = bias\n\n    def compute_params(self):\n        params = self.input_shape * self.neurons + self.neurons\n        return params\n\n    def compute_output_shape(self, input_shape):\n        return (self.neurons,)\n\n    def __str__(self):\n        return (f\"Dense Layer: {self.params} parameters, \"\n                f\"neurons: {self.neurons}, \"\n                f\"Activation: {self.activation}\")\n\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def compute_output_shape(self, input_shape):\n        return input_shape\n\n    def __str__(self):\n        return f\"Dropout Layer: rate={self.rate}, trainable parameters: 0\"\n\nclass Flatten(Layer):\n    def __init__(self):\n        super().__init__()\n\n    def compute_output_shape(self, input_shape):\n        return (input_shape[0] * input_shape[1] * input_shape[2],)\n\n    def __str__(self):\n        return \"Flatten Layer\"\n\nclass MaxPooling2D(Layer):\n    def __init__(self, pool_size, strides=None, padding='valid'):\n        super().__init__()\n        self.pool_size = pool_size\n        self.strides = strides if strides else pool_size\n        self.padding = padding\n\n    def compute_output_shape(self, input_shape):\n        if self.padding == 'same':\n            output_height = input_shape[0] // self.strides[0]\n            output_width = input_shape[1] // self.strides[1]\n        else:\n            output_height = (input_shape[0] - self.pool_size[0]) // self.strides[0] + 1\n            output_width = (input_shape[1] - self.pool_size[1]) // self.strides[1] + 1\n        return (output_height, output_width, input_shape[2])\n\n    def __str__(self):\n        return f\"MaxPooling2D Layer: pool_size={self.pool_size}, trainable parameters: 0\"\n\nclass CNNModel:\n    def __init__(self):\n        self.layers = []\n        self.input_shape = None\n\n    def add(self, layer):\n        if not self.layers:\n            if isinstance(layer, Conv2D) and layer.input_shape is not None:\n                layer.output_shape = layer.compute_output_shape(layer.input_shape)\n                layer.params = layer.compute_params()\n            else:\n                raise ValueError(\"The first layer must be a Conv2D layer with an input shape.\")\n        else:\n            layer.input_shape = self.layers[-1].output_shape\n            layer.output_shape = layer.compute_output_shape(layer.input_shape)\n            if isinstance(layer, Conv2D):\n                layer.params = layer.compute_params()\n            elif isinstance(layer, Dense):\n                layer.input_shape = self.layers[-1].output_shape[0]\n                layer.params = layer.compute_params()\n        self.layers.append(layer)\n\n    def summary(self):\n        total_params = 0\n        summary_table = \"| Layer (type) | Output Shape | Param # |\\n\"\n        summary_table += \"|--------------|--------------|---------|\\n\"\n        for i, layer in enumerate(self.layers):\n            summary_table += f\"| {layer.__class__.__name__} | {layer.output_shape} | {layer.params} |\\n\"\n            total_params += layer.params\n        summary_table += f\"| **Total** | | **{total_params}** |\\n\"\n        print(summary_table)\n\n# Create the CNN model\nmodel = CNNModel()\n\n# Add layers using a simple API\nmodel.add(Conv2D(filters=16, kernel_size=(3, 3), activation='relu', input_shape=(64, 64, 3)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(filters=32, kernel_size=(3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(filters=32, kernel_size=(3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Flatten())\nmodel.add(Dense(neurons=256, activation='relu'))\nmodel.add(Dense(neurons=10, activation='softmax'))\n\n# Print the model summary\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n| Layer (type) | Output Shape | Param # |\n|--------------|--------------|---------|\n| Conv2D | (62, 62, 16) | 448 |\n| MaxPooling2D | (31, 31, 16) | 0 |\n| Conv2D | (29, 29, 32) | 4640 |\n| MaxPooling2D | (14, 14, 32) | 0 |\n| Conv2D | (12, 12, 32) | 9248 |\n| MaxPooling2D | (6, 6, 32) | 0 |\n| Flatten | (1152,) | 0 |\n| Dense | (256,) | 295168 |\n| Dense | (10,) | 2570 |\n| **Total** | | **312074** |\n\n```\n:::\n:::\n\n\n",
    "supporting": [
      "evaluationDVR1_files"
    ],
    "filters": [],
    "includes": {}
  }
}