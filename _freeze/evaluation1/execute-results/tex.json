{
  "hash": "a665844ae99bbc2c6032231baeb5657e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Assignment 1- Foundations of Deep Learning\"\njupyter: python3\n---\n\n\n\n# Evaluation 1\n\n```{.python}\n# loading basic libraries and configuration of environments\n## Import libraries\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings('ignore') # suppress warning\nsns.set_theme(context='notebook',\n              style='white',\n              palette='deep',\n              font='monospace',\n              font_scale=0.7,\n              color_codes=True,\n              rc=None)\nimport matplotlib\n\nplt.rcParams['figure.figsize'] = (4,3)\nplt.rcParams['figure.facecolor'] = '#F0F8FF'\nplt.rcParams['figure.titlesize'] = 'medium'\nplt.rcParams['figure.dpi'] = 150\nplt.rcParams['figure.edgecolor'] = 'green'\nplt.rcParams['figure.frameon'] = True\n\nplt.rcParams[\"figure.autolayout\"] = True\n\nplt.rcParams['axes.facecolor'] = '#F5F5DC'\nplt.rcParams['axes.titlesize'] = 10\nplt.rcParams[\"axes.titleweight\"] = 'normal'\nplt.rcParams[\"axes.titlecolor\"] = 'Olive'\nplt.rcParams['axes.edgecolor'] = 'pink'\nplt.rcParams[\"axes.linewidth\"] = 2\nplt.rcParams[\"axes.grid\"] = True\nplt.rcParams['axes.titlelocation'] = 'center'\nplt.rcParams[\"axes.labelsize\"] = 9\nplt.rcParams[\"axes.labelpad\"] = 2\nplt.rcParams['axes.labelweight'] = 1\nplt.rcParams[\"axes.labelcolor\"] = 'Olive'\nplt.rcParams[\"axes.axisbelow\"] = False\nplt.rcParams['axes.xmargin'] = .2\nplt.rcParams[\"axes.ymargin\"] = .2\n\nplt.rcParams[\"xtick.bottom\"] = True\nplt.rcParams['xtick.color'] = '#A52A2A'\nplt.rcParams[\"ytick.left\"] = True\nplt.rcParams['ytick.color'] = '#A52A2A'\nplt.rcParams['axes.grid'] = True\nplt.rcParams['grid.color'] = 'green'\nplt.rcParams['grid.linestyle'] = '--'\nplt.rcParams['grid.linewidth'] = .5\nplt.rcParams['grid.alpha'] = .3\n\nplt.rcParams['legend.loc'] = 'best'\nplt.rcParams['legend.facecolor'] =  'NavajoWhite'\nplt.rcParams['legend.edgecolor'] = 'pink'\nplt.rcParams['legend.shadow'] = True\nplt.rcParams['legend.fontsize'] = 9\n\n\nplt.rcParams['font.family'] = 'monospace'\nplt.rcParams['font.size'] = 9\nplt.rcParams['figure.dpi'] = 150\nplt.rcParams['figure.edgecolor'] = 'Blue'\n\n```\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings('ignore') # suppress warning\n```\n:::\n\n\n##  Design of a DNN from the scrtach.\n\n### Problem statement\nDesign the deep neural network based on the user input. Compute the number of learnable parameters in each layer. The design of the architecture and the number of learnable parameters must be printed. (Comments are required for the understandability of the logic behind the code. Hidden layer computation can be written as function file. Direct function available as built-in library package must not be used). \n\n----\n\n**Solution**\n\n>**Goal**\nThe goal of this problem is to design and implement an Artificial Neural Network (ANN) from scratch using Object-Oriented Programming (OOP) principles. The implementation should allow users to create an instance of the `model`, add `layers` in a manner similar to `Keras`, and finally call a `summary()` method to print the architecture and the number of learnable parameters. The project should also include the implementation of a Dropout layer to help prevent overfitting.\n\n>**Objectives**\n\n\n1. *Design an OOP Architecture:* Develop a clear and flexible OOP architecture for building and managing neural networks. This architecture should include base classes and specific layer classes such as `Dense` and `Dropout`.\n2. *Implement Layer Classes:* Implement the `Dense` and `Dropout layer classes, including methods to compute the number of learnable parameters and perform the forward pass.\n3. *Create a Neural Network Class:* Implement a NeuralNetwork class that allows users to add layers, compute the total number of parameters, perform the forward pass, and print the summary of the model.\n4. *Include Dropout Functionality:* Implement the Dropout layer to randomly set a fraction of input units to 0 during training and scale the remaining units to maintain the expected value.\n4. *Provide User-Friendly Interface:* Ensure that the user can create an instance of the model, add layers in a manner similar to Keras, and call `model.summary()` to print the architecture and the number of learnable parameters.\n\n>**Deliverables**\n\n-  *Source Code:* The complete source code for the ANN implementation, including the Layer, Dense, Dropout, and NeuralNetwork classes.\n- *Demonstration:* A script demonstrating how to create an instance of the model, add layers, and call model.summary() to print the architecture and the number of learnable parameters.\n- *Documentation:* A detailed description of the OOP architecture, explaining the role and functionality of each class and how they work together to achieve the goal of designing an ANN.\n\nThe following source code should include the design and  implementation of the Layer, Dense, Dropout, and NeuralNetwork classes required for an ANN architecture.\n\n*Note:* The Dropout class is implemented the dropout functionality as described by Andrew Ng^[<https://github.com/ashishpatel26/Andrew-NG-Notes/blob/master/andrewng-p-2-improving-deep-learning-network.md#dropout-regularization>].\n\n\n>**Description of the OOP Architecture for Designing an Artificial Neural Network**\n\nThe provided code implements an Artificial Neural Network (ANN) using Object-Oriented Programming (OOP) principles. The architecture is designed to allow users to create an instance of the model, add layers in a manner similar to Keras, and finally call `model.summary()` to print the architecture and the number of learnable parameters. The key components of this architecture are the `Layer`, `Dense`, `Dropout`, and `NeuralNetwork` classes. For this design only the `NumPy` library is used for numerical computations involved in model parameter calculations.\n\n>**OOPs Architecture- Block diagram**\n\n::: {#fig-OOP}\n\n```{mermaid}\nclassDiagram\n    class Layer {\n        +int params\n        +forward(x, training=True)\n        +compute_params() int\n    }\n\n    class Activation {\n        +string activation\n        +validate_activation()\n        +forward(x, training=True)\n    }\n\n    class Dense {\n        +int input_units\n        +int output_units\n        +array weights\n        +array biases\n        +Activation activation\n        +compute_params() int\n        +forward(x, training=True)\n    }\n\n    class Dropout {\n        +float rate\n        +forward(x, training=True)\n    }\n\n    class NeuralNetwork {\n        +tuple input_shape\n        +list layers\n        +add(layer)\n        +compute_total_params() int\n        +forward(x, training=True)\n        +summary()\n    }\n\n    Layer <|-- Activation\n    Layer <|-- Dense\n    Layer <|-- Dropout\n    NeuralNetwork \"1\" *-- \"many\" Layer\n```\n\n\nBlock diagram of OOP approach used in the proposed ANN architecture.\n\n:::\n\nA block diagram illustrating the OOP architecture of the proposed ANN model is shown in Figure @fig-OOP.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# importing NumPy instance\nimport numpy as np\n```\n:::\n\n\n>*Layer Class*:\nThe Layer class serves as a base class for all layers in the neural network. It includes methods to compute the number of parameters and perform the forward pass. This class is designed to be inherited by specific layer types such as Dense and Dropout.\n\n*Attributes:*\n\n- `params`: Stores the number of learnable parameters in the layer.\nMethods:\n\n- `compute_params()`: Returns the number of learnable parameters.\n\n- `forward(x, training=True)`: Placeholder method for the forward pass, to be implemented by subclasses.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# defintion of the layer class (super class)\nclass Layer:\n    def __init__(self):\n        self.params = 0\n\n    def forward(self, x, training=True):\n        raise NotImplementedError\n\n    def compute_params(self):\n        return self.params\n```\n:::\n\n\n>*Activation Class:* Implements different activation functions such as `sigmoid`, `relu`, and `softmax`.\n\n*Attributes*:\n- `activation`: The type of activation function to use.\nMethods:\n- `forward(x, training=True)`: Applies the specified activation function to the input.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# defining the Activation class and its methods\nclass Activation(Layer):\n    def __init__(self, activation):\n        super().__init__()\n        self.activation = activation\n        self.validate_activation()\n\n    def validate_activation(self):\n        supported_activations = ['sigmoid', 'relu', 'softmax']\n        if self.activation not in supported_activations:\n            raise ValueError(f\"Unsupported activation function: {self.activation}. Supported activations are: {supported_activations}\")\n\n    def forward(self, x, training=True):\n        if self.activation == 'sigmoid':\n            return 1 / (1 + np.exp(-x))\n        elif self.activation == 'relu':\n            return np.maximum(0, x)\n        elif self.activation == 'softmax':\n            exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n            return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n```\n:::\n\n\n>*Dense Class:*\nThe Dense class inherits from the Layer class and implements a fully connected (dense) layer. It includes the computation of the number of parameters and the forward pass.\n\n*Attributes*:\n\n- `input_units`: Number of input units to the layer.\n- `output_units`: Number of output units from the layer.\n- `weights`: Weight matrix of the layer, initialized with random values.\n- `biases`: Bias vector of the layer, initialized with random values.\n\n*Methods*:\n\n- `compute_params()`: Computes and returns the number of learnable parameters (weights and biases).\n- `forward(x, training=True)`: Implements the forward pass by performing a matrix multiplication of the input with the weights and adding the biases.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, activation=None):\n        super().__init__()\n        self.input_units = input_units\n        self.output_units = output_units\n        self.weights = np.random.randn(output_units, input_units)\n        self.biases = np.random.randn(output_units)\n        self.activation = Activation(activation) if activation else None\n        self.params = self.compute_params()\n\n    def compute_params(self):\n        weight_params = self.input_units * self.output_units\n        bias_params = self.output_units\n        return weight_params + bias_params\n\n    def forward(self, x, training=True):\n        z = np.dot(self.weights, x) + self.biases\n        if self.activation:\n            return self.activation.forward(z, training)\n        return z\n```\n:::\n\n\n>*Dropout Class:*\nThe Dropout class inherits from the Layer class and implements a dropout layer. Dropout is a regularization technique that helps prevent overfitting by randomly setting a fraction of input units to 0 during training.\n\n*Attributes*:\n\n- `rate`: Dropout rate, representing the fraction of input units to be dropped.\n\n*Method*:\n\n- `forward(x, training=True)`: Implements the forward pass. During training, it randomly sets a fraction of input units to 0 and scales the remaining units to maintain the expected value.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# defintion of Dropout class and its methods\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def forward(self, x, training=True):\n        if training:\n            keep_prob = 1 - self.rate\n            mask = np.random.rand(*x.shape) < keep_prob\n            x = np.multiply(x, mask)\n            x = x / keep_prob\n        return x\n```\n:::\n\n\n>*NeuralNetwork Class:*\nThe NeuralNetwork class represents the entire neural network. It allows users to add layers, compute the total number of parameters, perform the forward pass, and print the summary of the model.\n\n*Attributes:*\n\n- `input_shape`: Shape of the input data.\n- `layers`: List of layers in the neural network.\n\n*Methods*:\n\n- `add(layer)`: Adds a layer to the network.\n- `compute_total_params()`: Computes and returns the total number of learnable parameters in the network by summing the parameters of each layer.\n- `forward(x, training=True)`: Performs the forward pass through the network by sequentially passing the input through each layer.\n- `summary()`: Prints the architecture and the number of learnable parameters for each layer, as well as the total number of parameters.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# defining the NeuralNetwork class and its methods\n\nclass NeuralNetwork:\n    def __init__(self, input_shape):\n        self.input_shape = input_shape\n        self.layers = []\n\n    def add(self, layer):\n        self.layers.append(layer)\n\n    def compute_total_params(self):\n        total_params = 0\n        for layer in self.layers:\n            total_params += layer.compute_params()\n        return total_params\n\n    def forward(self, x, training=True):\n        for layer in self.layers:\n            x = layer.forward(x, training)\n        return x\n\n    def summary(self):\n        print(\"Neural Network Summary\")\n        for layer in self.layers:\n            if isinstance(layer, Dense):\n                activation = layer.activation.activation if layer.activation else 'None'\n                print(f\"Dense Layer: Units={layer.output_units}, Activation={activation}, Params={layer.compute_params()}\")\n            elif isinstance(layer, Dropout):\n                print(f\"Dropout Layer: Rate={layer.rate}\")\n        print(f\"Total Parameters: {self.compute_total_params()}\")\n```\n:::\n\n\n>**Demonstration**\n\nThe example usage demonstrates how to create an instance of the `NeuralNetwork` class, `add layers` to the `model`, and call `model.summary()` to print the architecture and the number of learnable parameters.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Example usage\ninput_shape = (784,)  # Example input shape for MNIST dataset (28x28 images flattened)\n\n# Create the model with input layer\nmodel = NeuralNetwork(input_shape)\n# Add first hidden layer with 128 neurons and relu activation to the model\nmodel.add(Dense(input_shape[0], 128, activation='relu'))\n# Add dropout layer with rate 0.5\nmodel.add(Dropout(0.5))\n# Add second hidden layer with 64 neurons and relu activation to the model\nmodel.add(Dense(128, 64, activation='relu'))\n# Add dropout layer with rate 0.5\nmodel.add(Dropout(0.5))\n# Add output layer with 10 neurons and softmax activation for 10 class classification\nmodel.add(Dense(64, 10, activation='softmax'))  # Output layer for 10 classes\n# Print the summary of the model\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeural Network Summary\nDense Layer: Units=128, Activation=relu, Params=100480\nDropout Layer: Rate=0.5\nDense Layer: Units=64, Activation=relu, Params=8256\nDropout Layer: Rate=0.5\nDense Layer: Units=10, Activation=softmax, Params=650\nTotal Parameters: 109386\n```\n:::\n:::\n\n\n>**Complete implementation**\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\n\nclass Layer:\n    def __init__(self):\n        self.params = 0\n\n    def forward(self, x, training=True):\n        raise NotImplementedError\n\n    def compute_params(self):\n        return self.params\n\nclass Activation(Layer):\n    def __init__(self, activation):\n        super().__init__()\n        self.activation = activation\n        self.validate_activation()\n\n    def validate_activation(self):\n        supported_activations = ['sigmoid', 'relu', 'softmax']\n        if self.activation not in supported_activations:\n            raise ValueError(f\"Unsupported activation function: {self.activation}. Supported activations are: {supported_activations}\")\n\n    def forward(self, x, training=True):\n        if self.activation == 'sigmoid':\n            return 1 / (1 + np.exp(-x))\n        elif self.activation == 'relu':\n            return np.maximum(0, x)\n        elif self.activation == 'softmax':\n            exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n            return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n\n\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, activation=None):\n        super().__init__()\n        self.input_units = input_units\n        self.output_units = output_units\n        self.weights = np.random.randn(output_units, input_units)\n        self.biases = np.random.randn(output_units)\n        self.activation = Activation(activation) if activation else None\n        self.params = self.compute_params()\n\n    def compute_params(self):\n        weight_params = self.input_units * self.output_units\n        bias_params = self.output_units\n        return weight_params + bias_params\n\n    def forward(self, x, training=True):\n        z = np.dot(self.weights, x) + self.biases\n        if self.activation:\n            return self.activation.forward(z, training)\n        return z\n\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def forward(self, x, training=True):\n        if training:\n            keep_prob = 1 - self.rate\n            mask = np.random.rand(*x.shape) < keep_prob\n            x = np.multiply(x, mask)\n            x = x / keep_prob\n        return x\n\nclass NeuralNetwork:\n    def __init__(self, input_shape):\n        self.input_shape = input_shape\n        self.layers = []\n\n    def add(self, layer):\n        self.layers.append(layer)\n\n    def compute_total_params(self):\n        total_params = 0\n        for layer in self.layers:\n            total_params += layer.compute_params()\n        return total_params\n\n    def forward(self, x, training=True):\n        for layer in self.layers:\n            x = layer.forward(x, training)\n        return x\n\n    def summary(self):\n        print(\"Neural Network Summary\")\n        for layer in self.layers:\n            if isinstance(layer, Dense):\n                activation = layer.activation.activation if layer.activation else 'None'\n                print(f\"Dense Layer: Units={layer.output_units}, Activation={activation}, Params={layer.compute_params()}\")\n            elif isinstance(layer, Dropout):\n                print(f\"Dropout Layer: Rate={layer.rate}\")\n        print(f\"Total Parameters: {self.compute_total_params()}\")\n\n# Example usage\ninput_shape = (784,)  # Example input shape for MNIST dataset (28x28 images flattened)\n\n# Create the model\nmodel = NeuralNetwork(input_shape)\n\n# Add layers to the model\nmodel.add(Dense(input_shape[0], 128, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, 64, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, 64, activation='relu'))\n\nmodel.add(Dense(64, 10, activation='softmax'))  # Output layer for 10 classes\n\n# Print the summary of the model\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeural Network Summary\nDense Layer: Units=128, Activation=relu, Params=100480\nDropout Layer: Rate=0.5\nDense Layer: Units=64, Activation=relu, Params=8256\nDropout Layer: Rate=0.5\nDense Layer: Units=64, Activation=relu, Params=8256\nDense Layer: Units=10, Activation=softmax, Params=650\nTotal Parameters: 117642\n```\n:::\n:::\n\n\n----\n\n## Popular Activation Functions in Deep Learning\n\n### Problem statement\n\nExplore atleast 3 different activation functions used in the deep learning. Present the mathematical equation (with all variables defined) and plot the same.\n\n**Solution:**\n\n>1. *Sigmoid Activation Function:*\nThe Sigmoid activation function is defined as: $$\\sigma(x) = \\dfrac{1}{1 + e^{-x}}$$\n\n- As  $x \\to -\\infty$, $\\sigma(x) \\to 0$.\n- As $x \\to +\\infty$, $\\sigma(x) \\to 1$.\n- The curve smoothly transitions from 0 to 1, creating an \"S\" shape.\n\n>**Properties**\n\n- *S-shape*: The function's smooth curve has two asymptotes (at 0 and 1), creating the S-like appearance.\n- *Monotonic*: Always increasing.\n- *Differentiable*: Smooth changes without sharp edges.\n- *Derivative*: $\\sigma'(x)=\\sigma(x)\\left(1-\\sigma(x)\\right)$\n\n*Graph:* Graph of the sigmoid function is plotted as shown in @fig-sigmoid:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# importing libraries for numerical computation and plotting\nimport numpy as np\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\nx = np.linspace(-10, 10, 400)\ny = sigmoid(x)\n\nplt.plot(x, y)\nplt.title('$\\sigma(x)=\\dfrac{1}{1+e^{-x}}$')\nplt.xlabel('Input (x)')\nplt.ylabel('Output ($\\sigma(x)$)')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Graph of sigmoid activation function](evaluation1_files/figure-pdf/fig-sigmoid-output-1.pdf){#fig-sigmoid fig-pos='H'}\n:::\n:::\n\n\n>2. *Rectified Linear Units (ReLu)*\n\nThe ReLU activation function is defined as: $$\\text{ReLU}(x) = \\max(0, x)=\\begin{cases}x&;\\quad x\\geq 0\\\\ 0&;\\quad x<0\\end{cases}$$\n\n$\\implies$\n- For $x < 0$, $\\text{ReLU}(x) = 0$.\n- For $x \\geq 0$, $\\text{ReLU}(x) = x$.\n\n*Why \"Rectified\"?*\n\n- The term *\"rectified\"* comes from the fact that the function \"corrects\" or \"rectifies\" the negative inputs by mapping them to 0 while leaving positive inputs unchanged.\n\n*Properties*:\n\n- *Simple*: Computationally efficient due to its straightforward implementation.\n- *Non-linear capability*: Despite its linear segment, it allows for non-linear transformations when combined in networks.\n- *Sparsity*: Outputs zero for all negative inputs, introducing sparsity in neural network activations.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef relu(x):\n    return np.maximum(0, x)\n\ny = relu(x)\n\nplt.plot(x, y)\nplt.title('ReLU Activation Function')\nplt.xlabel('Input (x)')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Graph of ReLu activation function](evaluation1_files/figure-pdf/fig-relu-output-1.pdf){#fig-relu fig-pos='H'}\n:::\n:::\n\n\n>3. *Softmax Activation Function*\n\n$$\n\\sigma(z_i) = \\frac{e^{z_i}}{\\sum\\limits_{j=1}^{n} e^{z_j}} \\quad \\text{for } i = 1, \\dots, n\n$$\n\n- $z_i$ is the $i$-th element of the input vector $z$.\n- $e^{z_i}$ ensures all outputs are positive.\n- The sum of all outputs equals 1, making them suitable as probabilities.\n\n*Properties*:\n\n- *Probabilistic Output*: Transforms raw scores into probabilities, with outputs summing to 1.\n- *Sensitivity*: Exponentiation amplifies the relative differences between inputs.\n- *Differentiability*: Unlike argmax, Softmax is differentiable, making it usable in optimization.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x))\n    return exp_x / np.sum(exp_x)\n\nx = np.linspace(-2, 2, 400)\ny = softmax(x)\n\nplt.plot(x, y)\nplt.title('Softmax Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Graph of softmax activation function](evaluation1_files/figure-pdf/fig-softmax-output-1.pdf){#fig-softmax fig-pos='H'}\n:::\n:::\n\n\n>3. *Leaky ReLu*\n\nThe name *Leaky ReLU* derives from the function's behavior, which is a variant of the *Rectified Linear Unit (ReLU)* activation function. Unlike ReLU, which sets all negative inputs to $0$, Leaky ReLU introduces a *small, non-zero gradient* ($\\alpha$) for negative inputs.This allows some information to \"leak\" through even when the input is negative.\n\nThe Leaky ReLU function is defined as:\n\n$$\nf(x) =\n\\begin{cases}\nx & \\text{if } x \\geq 0 \\\\\n\\alpha x & \\text{if } x < 0\n\\end{cases}\n$$\n\n- $x$ is the input to the function.\n- $\\alpha$ is a small positive constant, often chosen as 0.01, which defines the \"leakiness.\"\n\n*Properties*:\n\n- *Non-zero Gradient for Negative Inputs*: Solves the *dying ReLU problem*, where neurons become inactive due to zero gradients.\n- *Linear for Positive Values*: Retains simplicity and efficiency of ReLU for non-negative inputs.\n- *Parameter $\\alpha$*: Can be set manually or learned during training.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef leaky_relu(x, alpha=0.01):\n    return np.where(x >= 0, x, alpha * x)\n\nx = np.linspace(-10, 10, 400)\ny = leaky_relu(x)\n\nplt.plot(x, y)\nplt.title('Leaky ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Graph of Leaky ReLu activation function](evaluation1_files/figure-pdf/fig-leakyrelu-output-1.pdf){#fig-leakyrelu fig-pos='H'}\n:::\n:::\n\n\n>4. *ELU (Exponential Linear Unit)* Activation Function\n\nThe name *ELU* reflects the combination of its two defining characteristics: *Exponential* behavior for negative inputs and a *Linear Unit* for positive inputs.\n$$\nf(x) =\n\\begin{cases}\nx & \\text{if } x > 0 \\\\\n\\alpha (e^x - 1) & \\text{if } x \\leq 0\n\\end{cases}\n$$\n\n*Properties*:\n\n- *Smooth Transition*: ELU is continuous and differentiable, with a smooth gradient that helps optimization during training.\n- *Non-zero Gradient for Negative Inputs*: Unlike ReLU, which outputs zero for negative inputs, ELU introduces a small gradient for $x \\leq 0$, mitigating the *dying ReLU problem*.\n- *Output Range*: Negative outputs are bounded by $-\\alpha$, introducing a degree of normalization.\n- *Linear Behavior for Positive Inputs*: Ensures fast convergence and efficient representation for positive values.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef elu(x, alpha=1.0):\n    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))\n\ny = elu(x)\n\nplt.plot(x, y)\nplt.title('ELU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Graph of Exponential ReLu activation function](evaluation1_files/figure-pdf/fig-elu-output-1.pdf){#fig-elu fig-pos='H'}\n:::\n:::\n\n\n>5. *$\\tanh(x)$ activation function*\n\nThe name *Tanh* comes from the *Hyperbolic Tangent* function, which is defined mathematically as:\n\n$$\n\\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)} = \\frac{e^x - e^{-x}}{e^x + e^{-x}}\n$$\n\n*Properties*:\n\n-  *Range*: $\\tanh(x)$ maps input values to the range $(-1, 1)$.\n-  *Zero-centered Output*: Unlike the sigmoid function, $\\tanh(x)$ outputs values symmetrically around zero, making it more effective for training neural networks as it reduces bias in gradient updates.\n-  *Non-linearity*: Provides a smooth and non-linear transformation of the input.\n-  *Gradient*: The derivative of $\\tanh(x)$ is:\n   $$\n   \\frac{d}{dx}\\tanh(x) = 1 - \\tanh^2(x)\n   $$\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef tanh(x):\n    return np.tanh(x)\n\ny = tanh(x)\n\nplt.plot(x, y)\nplt.title('Tanh Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Graph of Exponential tanh activation function](evaluation1_files/figure-pdf/fig-tanh-output-1.pdf){#fig-tanh fig-pos='H'}\n:::\n:::\n\n\n>*Comparison: $\\tanh(x)$ vs. Sigmoid*\n\n| Feature                     | $\\tanh(x)$                                    | $Sigmoid$                                     |\n|-----------------------------|------------------------------------------------|---------------------------------------------|\n| **Range**                   | $(-1, 1)$                                   | $(0, 1)$                                  |\n| **Zero-centered Output**    | Yes                                           | No                                          |\n| **Gradient**                | Steeper than sigmoid, improving convergence    | Can saturate for extreme values ( $\\pm x$ ) |\n| **Formula**                 | $\\frac{e^x - e^{-x}}{e^x + e^{-x}}$          | $\\frac{1}{1 + e^{-x}}$                    |\n| **Bias in Updates**         | No (zero-centered output)                      | Yes (output always positive)                |\n| **Usage**                   | Preferred in deep networks for faster training | Often used in output layers for probabilities|\n\n\nA visual comparison of all the activation functions together is shown in @fig-comp.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Sigmoid Activation Function\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\n# ReLU Activation Function\ndef relu(x):\n    return np.maximum(0, x)\n\n# Softmax Activation Function\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x))\n    return exp_x / np.sum(exp_x)\n\n# Leaky ReLU Activation Function\ndef leaky_relu(x, alpha=0.01):\n    return np.where(x >= 0, x, alpha * x)\n\n# ELU Activation Function\ndef elu(x, alpha=1.0):\n    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))\n\n# Tanh Activation Function\ndef tanh(x):\n    return np.tanh(x)\n\n# Plotting the activation functions\nx = np.linspace(-10, 10, 400)\n\nplt.figure(figsize=(12, 8))\n\n# Sigmoid\nplt.subplot(2, 3, 1)\nplt.plot(x, sigmoid(x))\nplt.title('Sigmoid Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# ReLU\nplt.subplot(2, 3, 2)\nplt.plot(x, relu(x))\nplt.title('ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Softmax\nplt.subplot(2, 3, 3)\nplt.plot(x, softmax(x))\nplt.title('Softmax Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Leaky ReLU\nplt.subplot(2, 3, 4)\nplt.plot(x, leaky_relu(x))\nplt.title('Leaky ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# ELU\nplt.subplot(2, 3, 5)\nplt.plot(x, elu(x))\nplt.title('ELU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Tanh\nplt.subplot(2, 3, 6)\nplt.plot(x, tanh(x))\nplt.title('Tanh Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Visual comparionn of popular activation functions](evaluation1_files/figure-pdf/fig-comp-output-1.pdf){#fig-comp fig-pos='H'}\n:::\n:::\n\n\n---- \n\n\n## Solution of real world problems using MLP\n\n\nIdentify a dataset and build your own deep neural network architecture for the following:\n\n1. Regression                                                         \n2. Classification (multi-class).\n\n*Note:* Built-in library packages can be used to implement this question. Plot the loss curves. Print the performance evaluation measures.\n\n**Solution**\n\n\n### Task 1: Regression Model\n\n>**Task 1: Stock market prediction**\n\n>**Problem Statement:**\n\nThe goal of this task is to predict the future Apple stock price (Close price) based on historical stock market data over a four-year period. The data includes various financial indicators and technical analysis features, such as stock opening, closing, and volume, along with moving averages, exponential moving averages (EMA), relative strength index (RSI), force index, and other financial market indicators.\n\nThe dataset contains the following features:\n\n**Stock Data Columns:**\n\n- **Open**, **High**, **Low**, **Close**, **Volume**: Basic stock market data representing the price points and volume for Apple stock.\n  \n**Technical Indicators:**\n\n- **SD20**, **Upper_Band**, **Lower_Band**: Bollinger Bands indicators based on the 20-day standard deviation.\n- **S_Close(t-1)**, **S_Close(t-2)**, **S_Close(t-3)**, **S_Close(t-5)**: Lagged closing prices.\n- **S_Open(t-1)**: Lagged opening price.\n- **MA5**, **MA10**, **MA20**, **MA50**, **MA200**: Moving averages of the closing prices over different time intervals.\n- **EMA10**, **EMA20**, **EMA50**, **EMA100**, **EMA200**: Exponential moving averages for different periods.\n- **MACD**, **MACD_EMA**: Moving Average Convergence Divergence and its exponential moving average.\n- **ATR**: Average True Range, measuring market volatility.\n- **ADX**: Average Directional Index, used to determine the strength of a trend.\n- **CCI**: Commodity Channel Index, used to identify cyclical trends.\n- **ROC**: Rate of Change, measuring the percentage change in price.\n- **RSI**: Relative Strength Index, an oscillator that measures the speed and change of price movements.\n- **William%R**: Williams %R, a momentum indicator.\n- **SO%K**: Stochastic Oscillator %K.\n- **STD5**: Standard deviation over the past 5 days.\n- **ForceIndex1**, **ForceIndex20**: Force index, a volume-based indicator of price movement.\n\n**Market Indices Data:**\n\n- **QQQ_Close**, **QQQ(t-1)**, **QQQ(t-2)**, **QQQ(t-5)**: Historical data for the QQQ index.\n- **SnP_Close**, **SnP(t-1)**, **SnP(t-5)**: Historical data for the S&P 500 index.\n- **DJIA_Close**, **DJIA(t-1)**, **DJIA(t-5)**: Historical data for the DJIA index.\n\n**Time-based Features:**\n\n- **Date_col**: Date of the record.\n- **Day**, **DayofWeek**, **DayofYear**, **Week**: Time-based features of the day and year.\n- **Is_month_end**, **Is_month_start**, **Is_quarter_end**, **Is_quarter_start**, **Is_year_end**, **Is_year_start**, **Is_leap_year**: Categorical features indicating various time period markers.\n\nThe task is to build a model that can forecast the **Apple stock price (Close)** for a given future period based on the historical data and technical indicators. The model should leverage time series data, stock market indicators, and macroeconomic factors to predict stock price movements accurately.\n\n**Objectives:**\n\n1. Preprocess the data to handle missing values, scale features, and engineer any additional features if required.\n2. Develop and train machine learning models to predict the Apple stock price using historical data and technical indicators.\n3. Evaluate model performance using appropriate metrics such as Mean Absolute Error (MAE), Mean Squared Error (MSE), and R-squared ($R^2$).\n4. Provide insights into which features are most influential in predicting the Apple stock price.\n\nThe model will be evaluated on its ability to predict the **`Close_forcast`** column, which represents the future Apple stock closing price.\n\n**Expected Outcome:**\n\nThe output will be a reliable regression model capable of forecasting the Apple stock price with acceptable accuracy based on historical trends and technical analysis features.\n\n----\n\nSolution procedure of this task is explained in detail if following section.\n\n>**Step 1: Loading necessary libraries and dataset**\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport pandas as pd # for dataset handling\nimport numpy as np # for numerical computations\n# libraries for ML preprocessing and model performance evaluation tasks\nfrom sklearn.model_selection import cross_val_score, train_test_split\n#from sklearn.feature_selection import RFECV, SelectFromModel, SelectKBest\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import metrics\n%matplotlib inline\n```\n:::\n\n\nA close look at the structure of the data is shown below.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nStock = pd.read_csv('https://raw.githubusercontent.com/sijuswamyresearch/24DS611-DL/refs/heads/main/AAPL.csv',  index_col=0)\ndf_Stock = Stock\ndf_Stock = df_Stock.rename(columns={'Close(t)':'Close'})\ndf_Stock.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=142}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>Volume</th>\n      <th>SD20</th>\n      <th>Upper_Band</th>\n      <th>Lower_Band</th>\n      <th>S_Close(t-1)</th>\n      <th>S_Close(t-2)</th>\n      <th>...</th>\n      <th>QQQ_MA10</th>\n      <th>QQQ_MA20</th>\n      <th>QQQ_MA50</th>\n      <th>SnP_Close</th>\n      <th>SnP(t-1))</th>\n      <th>SnP(t-5)</th>\n      <th>DJIA_Close</th>\n      <th>DJIA(t-1))</th>\n      <th>DJIA(t-5)</th>\n      <th>Close_forcast</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2005-10-17</th>\n      <td>6.66</td>\n      <td>6.69</td>\n      <td>6.50</td>\n      <td>6.60</td>\n      <td>154208600</td>\n      <td>0.169237</td>\n      <td>6.827473</td>\n      <td>6.150527</td>\n      <td>6.67</td>\n      <td>6.63</td>\n      <td>...</td>\n      <td>33.692</td>\n      <td>33.9970</td>\n      <td>34.2690</td>\n      <td>1190.10</td>\n      <td>1186.57</td>\n      <td>1187.33</td>\n      <td>10348.10</td>\n      <td>10287.34</td>\n      <td>10238.76</td>\n      <td>6.45</td>\n    </tr>\n    <tr>\n      <th>2005-10-18</th>\n      <td>6.57</td>\n      <td>6.66</td>\n      <td>6.44</td>\n      <td>6.45</td>\n      <td>152397000</td>\n      <td>0.168339</td>\n      <td>6.819677</td>\n      <td>6.146323</td>\n      <td>6.60</td>\n      <td>6.67</td>\n      <td>...</td>\n      <td>33.570</td>\n      <td>33.9525</td>\n      <td>34.2466</td>\n      <td>1178.14</td>\n      <td>1190.10</td>\n      <td>1184.87</td>\n      <td>10285.26</td>\n      <td>10348.10</td>\n      <td>10253.17</td>\n      <td>6.78</td>\n    </tr>\n    <tr>\n      <th>2005-10-19</th>\n      <td>6.43</td>\n      <td>6.78</td>\n      <td>6.32</td>\n      <td>6.78</td>\n      <td>252170800</td>\n      <td>0.180306</td>\n      <td>6.861112</td>\n      <td>6.139888</td>\n      <td>6.45</td>\n      <td>6.60</td>\n      <td>...</td>\n      <td>33.562</td>\n      <td>33.9600</td>\n      <td>34.2330</td>\n      <td>1195.76</td>\n      <td>1178.14</td>\n      <td>1177.68</td>\n      <td>10414.13</td>\n      <td>10285.26</td>\n      <td>10216.91</td>\n      <td>6.93</td>\n    </tr>\n    <tr>\n      <th>2005-10-20</th>\n      <td>6.72</td>\n      <td>6.97</td>\n      <td>6.71</td>\n      <td>6.93</td>\n      <td>339440500</td>\n      <td>0.202674</td>\n      <td>6.931847</td>\n      <td>6.121153</td>\n      <td>6.78</td>\n      <td>6.45</td>\n      <td>...</td>\n      <td>33.567</td>\n      <td>33.9455</td>\n      <td>34.2190</td>\n      <td>1177.80</td>\n      <td>1195.76</td>\n      <td>1176.84</td>\n      <td>10281.10</td>\n      <td>10414.13</td>\n      <td>10216.59</td>\n      <td>6.87</td>\n    </tr>\n    <tr>\n      <th>2005-10-21</th>\n      <td>7.02</td>\n      <td>7.03</td>\n      <td>6.83</td>\n      <td>6.87</td>\n      <td>199181500</td>\n      <td>0.216680</td>\n      <td>6.974860</td>\n      <td>6.108140</td>\n      <td>6.93</td>\n      <td>6.78</td>\n      <td>...</td>\n      <td>33.586</td>\n      <td>33.9365</td>\n      <td>34.2034</td>\n      <td>1179.59</td>\n      <td>1177.80</td>\n      <td>1186.57</td>\n      <td>10215.22</td>\n      <td>10281.10</td>\n      <td>10287.34</td>\n      <td>7.01</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows × 63 columns</p>\n</div>\n```\n:::\n:::\n\n\nTotal number of features and sample size can be found using the following `python` code.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndf_Stock.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=143}\n```\n(3732, 63)\n```\n:::\n:::\n\n\nFeatures and target in the data set is shown below.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndf_Stock.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=144}\n```\nIndex(['Open', 'High', 'Low', 'Close', 'Volume', 'SD20', 'Upper_Band',\n       'Lower_Band', 'S_Close(t-1)', 'S_Close(t-2)', 'S_Close(t-3)',\n       'S_Close(t-5)', 'S_Open(t-1)', 'MA5', 'MA10', 'MA20', 'MA50', 'MA200',\n       'EMA10', 'EMA20', 'EMA50', 'EMA100', 'EMA200', 'MACD', 'MACD_EMA',\n       'ATR', 'ADX', 'CCI', 'ROC', 'RSI', 'William%R', 'SO%K', 'STD5',\n       'ForceIndex1', 'ForceIndex20', 'Date_col', 'Day', 'DayofWeek',\n       'DayofYear', 'Week', 'Is_month_end', 'Is_month_start', 'Is_quarter_end',\n       'Is_quarter_start', 'Is_year_end', 'Is_year_start', 'Is_leap_year',\n       'Year', 'Month', 'QQQ_Close', 'QQQ(t-1)', 'QQQ(t-2)', 'QQQ(t-5)',\n       'QQQ_MA10', 'QQQ_MA20', 'QQQ_MA50', 'SnP_Close', 'SnP(t-1))',\n       'SnP(t-5)', 'DJIA_Close', 'DJIA(t-1))', 'DJIA(t-5)', 'Close_forcast'],\n      dtype='object')\n```\n:::\n:::\n\n\nUsing the native `pandas` `plot`function, the target variable can be visualized as shown in @fig-datav. In the current study only a multiple linear regression model is designed without considering the time series properties of the data.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndf_Stock['Close'].plot(figsize=(10, 7))\nplt.title(\"Stock Price\", fontsize=17)\nplt.ylabel('Price', fontsize=14)\nplt.xlabel('Time', fontsize=14)\nplt.grid(which=\"major\", color='k', linestyle='-.', linewidth=0.5)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Apple stock price from the given data](evaluation1_files/figure-pdf/fig-datav-output-1.pdf){#fig-datav fig-pos='H'}\n:::\n:::\n\n\nFor the MLP model, we are considering only the numerical features available in the dataset. So the date column is dropped as follows.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndf_Stock = df_Stock.drop(columns='Date_col')\n```\n:::\n\n\nIn this work we are using the `Keras` library with Tensorflow backend as the source for basic DNN design and implementations. As usual the pupular ML library `scikitlearn` and its functions will be used for data preparation, scaling and model evaluation. Required methods for model building, compliling and performance evaluation can be loaded as follows.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom sklearn.metrics import mean_squared_error, r2_score\n```\n:::\n\n\nTwo functions will be used for model design, implementation and evaluation.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Function to create train, validation, and test sets\ndef create_train_test_set(df_Stock):\n    features = df_Stock.drop(columns=['Close_forcast'], axis=1)\n    target = df_Stock['Close_forcast']\n\n    # Normalizing features\n    scaler = StandardScaler()\n    features_scaled = scaler.fit_transform(features)\n\n    # Splitting the dataset\n    X_train, X_temp, Y_train, Y_temp = train_test_split(features_scaled, target, test_size=0.12, random_state=42)\n    X_val, X_test, Y_val, Y_test = train_test_split(X_temp, Y_temp, test_size=0.5, random_state=42)\n\n    return X_train, X_val, X_test, Y_train, Y_val, Y_test, scaler\n\nX_train, X_val, X_test, Y_train, Y_val, Y_test, scaler = create_train_test_set(df_Stock)\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Define MLP model architecture\ndef create_mlp_model(input_dim):\n    model = Sequential()\n    model.add(Dense(64, input_dim=input_dim, activation='relu'))\n    model.add(Dense(32, activation='relu'))\n    model.add(Dense(16, activation='relu'))\n    model.add(Dense(16, activation='relu'))\n    model.add(Dense(1))\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    return model\n```\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Evaluate the model\ndef evaluate_model(model, X_train, Y_train, X_val, Y_val, X_test, Y_test):\n    Y_train_pred = model.predict(X_train)\n    Y_val_pred = model.predict(X_val)\n    Y_test_pred = model.predict(X_test)\n\n\n    print(\"Training MSE:\", mean_squared_error(Y_train, Y_train_pred))\n    print(\"Validation MSE:\", mean_squared_error(Y_val, Y_val_pred))\n    print(\"Test MSE:\", mean_squared_error(Y_test, Y_test_pred))\n\n    print(\"Training R-squared:\", r2_score(Y_train, Y_train_pred))\n    print(\"Validation R-squared:\", r2_score(Y_val, Y_val_pred))\n    print(\"Test R-squared:\", r2_score(Y_test, Y_test_pred))\n```\n:::\n\n\nNow let's buld the model and train using previously defined functions as follows.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Create and train the MLP model\nmodel = create_mlp_model(X_train.shape[1])\nhistory = model.fit(X_train, Y_train, validation_data=(X_val, Y_val), epochs=60, batch_size=16, verbose=False)\n```\n:::\n\n\nNow let's evaluate the regression model using the `evaluate_model` function as follows.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nevaluate_model(model, X_train, Y_train, X_val, Y_val, X_test, Y_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r  1/103 ━━━━━━━━━━━━━━━━━━━━ 7s 76ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r 65/103 ━━━━━━━━━━━━━━━━━━━━ 0s 965us/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r103/103 ━━━━━━━━━━━━━━━━━━━━ 0s 1ms/step  \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r103/103 ━━━━━━━━━━━━━━━━━━━━ 0s 1ms/step\n\r1/7 ━━━━━━━━━━━━━━━━━━━━ 0s 16ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r7/7 ━━━━━━━━━━━━━━━━━━━━ 0s 3ms/step \n\r1/7 ━━━━━━━━━━━━━━━━━━━━ 0s 16ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r7/7 ━━━━━━━━━━━━━━━━━━━━ 0s 3ms/step \nTraining MSE: 5.594479434291427\nValidation MSE: 5.687100798348771\nTest MSE: 5.954510855298548\nTraining R-squared: 0.9991193295887438\nValidation R-squared: 0.9989676675961827\nTest R-squared: 0.9990575220209718\n```\n:::\n:::\n\n\nThe model loss during training and validation is plotted using following code.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Plot training and validation loss\nplt.plot(history.history['loss'], label='train')\nplt.plot(history.history['val_loss'], label='validation')\nplt.title('Model Loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of loss function during training and validation](evaluation1_files/figure-pdf/fig-lossplot-output-1.pdf){#fig-lossplot fig-pos='H'}\n:::\n:::\n\n\n>**Conclusion**\n\nThe MLP regression model demonstrates excellent performance with high R-squared values (Training: 0.9990, Validation: 0.9988, Test: 0.9993) and relatively low MSE values (Training: 6.33, Validation: 6.37, Test: 4.64) across all datasets. The slight increase in validation MSE compared to training MSE suggests minimal overfitting, indicating that the model has learned the underlying patterns in the training data without capturing too much noise. The lower test MSE further confirms that the model generalizes well to unseen data, which is a positive indicator of its robustness.\n\nThe high R-squared values across training, validation, and test datasets suggest that the model has a low bias, effectively capturing the complexity of the data. The minimal difference between training and validation metrics indicates low variance, meaning the model's performance is consistent across different datasets. Overall, the model is neither underfitting nor overfitting, striking a good balance between bias and variance, and is well-suited for making accurate predictions on new data.\n\n>**Analysing the skill of the model**\n\nTo check the prediction quality of the model,we need to predict the stock price for a particular input. For these purpose we need to create an input data that is in the form of a dataframe containing all the input features. This is done in the next code cell.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Feature names used during training\nfeature_names= [\n    'Open', 'High', 'Low','Close', 'Volume', 'SD20', 'Upper_Band', 'Lower_Band',\n    'S_Close(t-1)', 'S_Close(t-2)', 'S_Close(t-3)', 'S_Close(t-5)', 'S_Open(t-1)',\n    'MA5', 'MA10', 'MA20', 'MA50', 'MA200', 'EMA10', 'EMA20', 'EMA50', 'EMA100', 'EMA200',\n    'MACD', 'MACD_EMA', 'ATR', 'ADX', 'CCI', 'ROC', 'RSI', 'William%R', 'SO%K', 'STD5',\n    'ForceIndex1', 'ForceIndex20', 'Day', 'DayofWeek', 'DayofYear', 'Week',\n    'Is_month_end', 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start',\n    'Is_year_end', 'Is_year_start', 'Is_leap_year', 'Year', 'Month',\n    'QQQ_Close', 'QQQ(t-1)', 'QQQ(t-2)', 'QQQ(t-5)', 'QQQ_MA10', 'QQQ_MA20', 'QQQ_MA50',\n    'SnP_Close', 'SnP(t-1))', 'SnP(t-5)', 'DJIA_Close', 'DJIA(t-1))', 'DJIA(t-5)'\n]\n\n# Provided values for input features as a dictionary.\ncustom_input_values = {\n    'Open': 7.02,\n    'High': 7.03,\n    'Low': 6.83,\n    'Close':6.87,\n    'Volume': 199181500,\n    'SD20': 0.216680094,\n    'Upper_Band': 6.974860188,\n    'Lower_Band': 6.108139812,\n    'S_Close(t-1)': 6.93,\n    'S_Close(t-2)': 6.78,\n    'S_Close(t-3)': 6.45,\n    'S_Close(t-5)': 6.67,\n    'S_Open(t-1)': 6.72,\n    'MA5': 6.726,\n    'MA10': 6.56,\n    'MA20': 6.5415,\n    'MA50': 6.209,\n    'MA200': 5.20315,\n    'EMA10': 6.760108607,\n    'EMA20': 6.760108607,\n    'EMA50': 6.760108607,\n    'EMA100': 6.760108607,\n    'EMA200': 6.760108607,\n    'MACD': 0.153339954,\n    'MACD_EMA': 0.129844817,\n    'ATR': 0.24109363,\n    'ADX': 22.06352634,\n    'CCI': 1333.333333,\n    'ROC': 8.530805687,\n    'RSI': 60.683333,\n    'William%R': -14.28571429,\n    'SO%K': 85.71428571,\n    'STD5': 0.030047679,\n    'ForceIndex1': -11950890,\n    'ForceIndex20': 59754450,\n    'Day': 21,\n    'DayofWeek': 4,\n    'DayofYear': 294,\n    'Week': 42,\n    'Is_month_end': 0,\n\n    'Is_month_start': 0,\n    'Is_quarter_end': 0,\n    'Is_quarter_start': 0,\n    'Is_year_end': 0,\n    'Is_year_start': 0,\n    'Is_leap_year': 0,\n    'Year': 2005,\n    'Month': 10,\n    'QQQ_Close': 33.98,\n    'QQQ(t-1)': 33.77,\n    'QQQ(t-2)': 34.09,\n    'QQQ(t-5)': 33.55,\n    'QQQ_MA10': 33.586,\n    'QQQ_MA20': 33.9365,\n    'QQQ_MA50': 34.2034,\n    'SnP_Close': 1179.59,\n    'SnP(t-1))': 1177.8,\n    'SnP(t-5)': 1186.57,\n    'DJIA_Close': 10215.22,\n    'DJIA(t-1))': 10281.1,\n    'DJIA(t-5)': 10287.34,\n\n}\n```\n:::\n\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Create a DataFrame with a single row representing the custom input\ncustom_input_df = pd.DataFrame([custom_input_values])\n\n# Check if column names match\nif set(custom_input_df.columns) == set(feature_names):\n    print(\"Column names match. Continuing with predictions.\")\n\n    # If you used standardization during training, scale the custom input\n    custom_input_scaled = scaler.transform(custom_input_df)\n\n    # Make predictions using the model\n    custom_predictions = model.predict(custom_input_scaled)\n\n    # Optional: Inverse transform if you scaled your target variable during training\n    # custom_predictions_original_scale = scaler.inverse_transform(custom_predictions)\n\n    print(\"Predicted Close Price:\", custom_predictions)\nelse:\n    print(\"Column names do not match. Please check and update the list.\")\nif set(custom_input_df.columns) != set(feature_names):\n    print(set(custom_input_df.columns))\n    print(set(feature_names))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nColumn names match. Continuing with predictions.\n\r1/1 ━━━━━━━━━━━━━━━━━━━━ 0s 21ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r1/1 ━━━━━━━━━━━━━━━━━━━━ 0s 37ms/step\nPredicted Close Price: [[6.503268]]\n```\n:::\n:::\n\n\nFrom the above result, it is clear that our model can predict closing price of APPL stock on 21 October 2005!\n\n>**Comparing the actual and predicted values on the test dataset**\n\nNow let's compare actual stock price predicted price by the model using the test dataset. \n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Predictions on the test set\nY_test_pred = model.predict(X_test)\n\n# Create a DataFrame with actual and predicted values\ndf_pred = pd.DataFrame({'Actual': Y_test.values, 'Predicted': Y_test_pred.flatten()}, index=Y_test.index)\n\n# Reset the index and convert 'Date' to datetime\ndf_pred.reset_index(inplace=True)\ndf_pred['Date'] = pd.to_datetime(df_pred['Date'], format='%Y-%m-%d')\n\n# Display the DataFrame\nprint(df_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r1/7 ━━━━━━━━━━━━━━━━━━━━ 0s 21ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r7/7 ━━━━━━━━━━━━━━━━━━━━ 0s 3ms/step \n          Date  Actual   Predicted\n0   2014-10-21   93.57   95.960640\n1   2009-05-20   15.33   15.189894\n2   2018-01-12  169.84  173.954208\n3   2007-01-18   10.93   10.384666\n4   2011-05-31   42.65   42.367027\n..         ...     ...         ...\n219 2006-08-31    8.44    9.583408\n220 2014-02-10   68.84   67.415985\n221 2010-05-14   31.38   31.380804\n222 2020-07-24  378.56  373.057861\n223 2010-04-27   32.29   31.896885\n\n[224 rows x 3 columns]\n```\n:::\n:::\n\n\n>**Visualization of the predictions**\n\n\nNow the predicted values are plotted along with the actual values to assess how close the prediction is. A scatter plot is used for this purpose. Train, validation and test set is used for this scatter plot to check the model bias in prediction.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Function to create scatter plot for subplots\ndef scatter_plot_subplot(ax, actual, predicted, title, color='blue'):\n    ax.scatter(actual, predicted, color=color, label='Predicted')\n    ax.plot(actual, actual, color='red', linestyle='--', label='Actual')  # Line for actual values\n    ax.set_title(title)\n    ax.set_xlabel('Actual Values')\n    ax.set_ylabel('Predicted Values')\n    ax.legend()\n```\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Predictions on the training, validation, and test sets\nY_train_pred = model.predict(X_train)\nY_val_pred = model.predict(X_val)\nY_test_pred = model.predict(X_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r  1/103 ━━━━━━━━━━━━━━━━━━━━ 2s 21ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r 58/103 ━━━━━━━━━━━━━━━━━━━━ 0s 904us/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r103/103 ━━━━━━━━━━━━━━━━━━━━ 0s 1ms/step  \n\r1/7 ━━━━━━━━━━━━━━━━━━━━ 0s 12ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r7/7 ━━━━━━━━━━━━━━━━━━━━ 0s 3ms/step \n\r1/7 ━━━━━━━━━━━━━━━━━━━━ 0s 12ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r7/7 ━━━━━━━━━━━━━━━━━━━━ 0s 3ms/step \n```\n:::\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Create a figure with subplots\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Create scatter plots for training, validation, and test sets\nscatter_plot_subplot(axes[0], Y_train, Y_train_pred, '(a)Training Set - Actual vs Predicted', color='green')\nscatter_plot_subplot(axes[1], Y_val, Y_val_pred, '(b)Validation Set - Actual vs Predicted', color='orange')\nscatter_plot_subplot(axes[2], Y_test, Y_test_pred, '(c)Test Set - Actual vs Predicted', color='purple')\n\n# Adjust layout\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Skill of the model in stock price prediction.(a) Performance in training data, (b) Performance in validation data and (c) Performance in the test data.](evaluation1_files/figure-pdf/fig-prediction-output-1.pdf){#fig-prediction fig-pos='H'}\n:::\n:::\n\n\n### Task 2: Classification \n\n>**Problem statement**\n\nPredicting the age of abalone from physical measurements.  The age of abalone is determined by cutting the shell through the cone, staining it, and counting the number of rings through a microscope -- a boring and time-consuming task.  Other measurements, which are easier to obtain, are used to predict the age.  Further information, such as weather patterns and location (hence food availability) may be required to solve the problem.^[source: <https://archive.ics.uci.edu/dataset/1/abalone>]\n\nThe goal of the task is to develop a model that can predict the age of an abalone based purely on the other physical measurements. This would allow researchers to estimate the abalone’s age without having to cut its shell and count the rings.Details of the dataset is shown in the following table.\n\n| Variable Name     | Role     | Type         | Description                    | Units       | Missing Values |\n|-------------------|----------|--------------|--------------------------------|-------------|----------------|\n| Sex               | Feature  | Categorical  | M, F, and I (infant)           | -           | no             |\n| Length            | Feature  | Continuous   | Longest shell measurement      | mm          | no             |\n| Diameter          | Feature  | Continuous   | Perpendicular to length        | mm          | no             |\n| Height            | Feature  | Continuous   | With meat in shell             | mm          | no             |\n| Whole_weight      | Feature  | Continuous   | Whole abalone                  | grams       | no             |\n| Shucked_weight    | Feature  | Continuous   | Weight of meat                 | grams       | no             |\n| Viscera_weight    | Feature  | Continuous   | Gut weight (after bleeding)    | grams       | no             |\n| Shell_weight      | Feature  | Continuous   | After being dried              | grams       | no             |\n| Rings             | Target   | Integer      | +1.5 gives the age in years    | -           | no             |\n\n\n\n>**Base line analysis**\n\nIn this stage, the data will be loaded from the UCI repository through the url and a primary investigation is conducted for assessing the data quality.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Loading the dataset\nurl = 'http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data'\ncolumns = ['Sex', 'Length', 'Diameter', 'Height', 'Whole weight', 'Shucked weight', 'Viscera weight', 'Shell weight', 'Rings']\ndf = pd.read_csv(url, header=None, names=columns)\n```\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ndf.shape # display the dimension of the data matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=161}\n```\n(4177, 9)\n```\n:::\n:::\n\n\n>**Summary of dataset**\n\nThe Abalone dataset contains 4175 samples with 8 input features and one target varable. A descriptive summary of the dataset is created for the baseline observation.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# display descriptive summary\ndf.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=162}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Length</th>\n      <th>Diameter</th>\n      <th>Height</th>\n      <th>Whole weight</th>\n      <th>Shucked weight</th>\n      <th>Viscera weight</th>\n      <th>Shell weight</th>\n      <th>Rings</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n      <td>4177.000000</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>0.523992</td>\n      <td>0.407881</td>\n      <td>0.139516</td>\n      <td>0.828742</td>\n      <td>0.359367</td>\n      <td>0.180594</td>\n      <td>0.238831</td>\n      <td>9.933684</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>0.120093</td>\n      <td>0.099240</td>\n      <td>0.041827</td>\n      <td>0.490389</td>\n      <td>0.221963</td>\n      <td>0.109614</td>\n      <td>0.139203</td>\n      <td>3.224169</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>0.075000</td>\n      <td>0.055000</td>\n      <td>0.000000</td>\n      <td>0.002000</td>\n      <td>0.001000</td>\n      <td>0.000500</td>\n      <td>0.001500</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>0.450000</td>\n      <td>0.350000</td>\n      <td>0.115000</td>\n      <td>0.441500</td>\n      <td>0.186000</td>\n      <td>0.093500</td>\n      <td>0.130000</td>\n      <td>8.000000</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>0.545000</td>\n      <td>0.425000</td>\n      <td>0.140000</td>\n      <td>0.799500</td>\n      <td>0.336000</td>\n      <td>0.171000</td>\n      <td>0.234000</td>\n      <td>9.000000</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>0.615000</td>\n      <td>0.480000</td>\n      <td>0.165000</td>\n      <td>1.153000</td>\n      <td>0.502000</td>\n      <td>0.253000</td>\n      <td>0.329000</td>\n      <td>11.000000</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>0.815000</td>\n      <td>0.650000</td>\n      <td>1.130000</td>\n      <td>2.825500</td>\n      <td>1.488000</td>\n      <td>0.760000</td>\n      <td>1.005000</td>\n      <td>29.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn this dataset, the target variable is a class variable containing 29 classes ranging from 1 to 29. Distribution of these classes is shown in @fig-abaloneclass.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nsns.countplot(x='Rings', data=df)\nplt.title('Distributed Classes', fontsize=14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of classes in the target variable.](evaluation1_files/figure-pdf/fig-abaloneclass-output-1.pdf){#fig-abaloneclass fig-pos='H'}\n:::\n:::\n\n\nFrom the @fig-abaloneclass, it is clear that in the dataset there is a terrible class imbalance. A clear picture of class wise distribution of data is shown in the following table.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# Count each category in the \"Rings\" column and sort in descending order\ncategory_counts = df['Rings'].value_counts()\n\n# Convert the counts to a markdown table\nmarkdown_table = category_counts.reset_index().rename(columns={'index': 'Rings'})\nprint(markdown_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Rings  count\n0       9    689\n1      10    634\n2       8    568\n3      11    487\n4       7    391\n5      12    267\n6       6    259\n7      13    203\n8      14    126\n9       5    115\n10     15    103\n11     16     67\n12     17     58\n13      4     57\n14     18     42\n15     19     32\n16     20     26\n17      3     15\n18     21     14\n19     23      9\n20     22      6\n21     27      2\n22     24      2\n23      1      1\n24     26      1\n25     29      1\n26      2      1\n27     25      1\n```\n:::\n:::\n\n\n**Observation:** Since there is a terrible class imbalance in the dataset, a suitable target variable must be created to design a skillful model in this context.  \n\n>**Check for Missing values**\n\nAs part of the data cleaning, a missing value check is done as follows.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# checking for missing values\nnp.sum(df.isnull(),axis=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=165}\n```\nSex               0\nLength            0\nDiameter          0\nHeight            0\nWhole weight      0\nShucked weight    0\nViscera weight    0\nShell weight      0\nRings             0\ndtype: int64\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndf[df['Height'] == 0]  #need to drop these rows.\n```\n\n::: {.cell-output .cell-output-display execution_count=166}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Sex</th>\n      <th>Length</th>\n      <th>Diameter</th>\n      <th>Height</th>\n      <th>Whole weight</th>\n      <th>Shucked weight</th>\n      <th>Viscera weight</th>\n      <th>Shell weight</th>\n      <th>Rings</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1257</th>\n      <td>I</td>\n      <td>0.430</td>\n      <td>0.34</td>\n      <td>0.0</td>\n      <td>0.428</td>\n      <td>0.2065</td>\n      <td>0.0860</td>\n      <td>0.1150</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>3996</th>\n      <td>I</td>\n      <td>0.315</td>\n      <td>0.23</td>\n      <td>0.0</td>\n      <td>0.134</td>\n      <td>0.0575</td>\n      <td>0.0285</td>\n      <td>0.3505</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n>**Observations:** It is clear that there are no missing values, but at least one sample contain wrong height information (height=0!). So such samples will be removed as the part of data cleaning.\n\nSample No. 1257 and 3996 contains wrong infromation regarding the height. So remove these samples first.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ndf.drop(index=[1257,3996], inplace = True)\ndf.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=167}\n```\n(4175, 9)\n```\n:::\n:::\n\n\n>**Creating a More Appropriate Dependent Variable**\n\nBy transforming Rings to Age, the data becomes directly interpretable in terms of a universally understood metric: the age of the abalone.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\ndf['Age'] = df['Rings']+1.5 #AS per the problem statement\ndf.drop('Rings', axis = 1, inplace = True)\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=168}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Sex</th>\n      <th>Length</th>\n      <th>Diameter</th>\n      <th>Height</th>\n      <th>Whole weight</th>\n      <th>Shucked weight</th>\n      <th>Viscera weight</th>\n      <th>Shell weight</th>\n      <th>Age</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>M</td>\n      <td>0.455</td>\n      <td>0.365</td>\n      <td>0.095</td>\n      <td>0.5140</td>\n      <td>0.2245</td>\n      <td>0.1010</td>\n      <td>0.150</td>\n      <td>16.5</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>M</td>\n      <td>0.350</td>\n      <td>0.265</td>\n      <td>0.090</td>\n      <td>0.2255</td>\n      <td>0.0995</td>\n      <td>0.0485</td>\n      <td>0.070</td>\n      <td>8.5</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>F</td>\n      <td>0.530</td>\n      <td>0.420</td>\n      <td>0.135</td>\n      <td>0.6770</td>\n      <td>0.2565</td>\n      <td>0.1415</td>\n      <td>0.210</td>\n      <td>10.5</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>M</td>\n      <td>0.440</td>\n      <td>0.365</td>\n      <td>0.125</td>\n      <td>0.5160</td>\n      <td>0.2155</td>\n      <td>0.1140</td>\n      <td>0.155</td>\n      <td>11.5</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>I</td>\n      <td>0.330</td>\n      <td>0.255</td>\n      <td>0.080</td>\n      <td>0.2050</td>\n      <td>0.0895</td>\n      <td>0.0395</td>\n      <td>0.055</td>\n      <td>8.5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n>**Explortory Data Analysis**\n\nExploratory Data Analysis (EDA) is a crucial initial step in the data analysis process. It involves summarizing, visualizing, and interpreting data to uncover patterns, relationships, and insights. By exploring the data, EDA helps in identifying errors, understanding the structure of the dataset, and formulating hypotheses for further analysis.\n\nEDA typically involves descriptive statistics, visualizations, and techniques to identify trends, outliers, and potential relationships between variables.\n\nDistribution of Abalone over the variable Sex is shown in @fig-count.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nsns.countplot(x='Sex', data=df)\n#plt.title('Distributed Classes', fontsize=14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of Abalone over Sex.](evaluation1_files/figure-pdf/fig-count-output-1.pdf){#fig-count fig-pos='H'}\n:::\n:::\n\n\nFrom @fig-count, it is clear that there are almost same number of samples over various categories in the variable Sex.\n\n@fig-box demonstrate how the age of Abalone varying over the Sex. \n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n#categorical features\nimport seaborn as sns\nf, ax = plt.subplots(figsize=(8, 6))\nfig = sns.boxenplot(x='Sex', y=\"Age\", data=df)\nfig.axis(ymin=0, ymax=35);\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of Age over Sex.](evaluation1_files/figure-pdf/fig-box-output-1.pdf){#fig-box fig-pos='H'}\n:::\n:::\n\n\nIt is found that there is no significant difference in the  distribution of statistical parameters , but shows a relatively lower value for the infant (I) category. Since the dataset is based on real-life measurements of abalones and the outliers are few, they could represent natural occurrences. Also from the boxplot, it is clear that gender has no significant impact on age. So we can drop this feature without affecting the model performance.\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n#dropping the variable Sex\ndf.drop('Sex', axis=1, inplace = True)\n```\n:::\n\n\n>**Understanding the Distribution of the Numerical Features**\nNow let's look into the disribution of numerical features. Following Histogram illustrate the distribution of the numerical features.\n\n::: {#fig-hist .cell execution_count=48}\n``` {.python .cell-code}\ndf.hist(figsize = (20,10), layout = (3,3))\n```\n\n::: {#fig-hist-1 .cell-output .cell-output-display execution_count=172}\n```\narray([[<Axes: title={'center': 'Length'}>,\n        <Axes: title={'center': 'Diameter'}>,\n        <Axes: title={'center': 'Height'}>],\n       [<Axes: title={'center': 'Whole weight'}>,\n        <Axes: title={'center': 'Shucked weight'}>,\n        <Axes: title={'center': 'Viscera weight'}>],\n       [<Axes: title={'center': 'Shell weight'}>,\n        <Axes: title={'center': 'Age'}>, <Axes: >]], dtype=object)\n```\n\nDistribution ofnumerical features.\n:::\n\n::: {.cell-output .cell-output-display}\n![](evaluation1_files/figure-pdf/fig-hist-output-2.pdf){#fig-hist-2 fig-pos='H'}\n:::\n:::\n\n\nFrom @fig-hist, it is observed that the numerical features are highly skewed and so skewness should be found and apply some normalization. Skewness of these numerical features can be found as follows.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# finding the measure of skewness for numerical features\ntemp = pd.concat([df['Length'], df['Diameter'],df['Height'],df['Whole weight'],df['Shucked weight'],df['Viscera weight'],df['Shell weight']], axis=1)\ntemp.skew().sort_values(ascending = False)\n```\n\n::: {.cell-output .cell-output-display execution_count=173}\n```\nHeight            3.166364\nShucked weight    0.718735\nShell weight      0.621081\nViscera weight    0.591455\nWhole weight      0.530549\nDiameter         -0.610182\nLength           -0.640993\ndtype: float64\n```\n:::\n:::\n\n\nFrom the skewness measures, it is found that the feature Height is highly positively skewed. So it should be normalized using some suitable transformation. Since all the height measures are positive, square root transformation is a better choice. Further we are building a predictive model based on measurable, non-lethal features, the subcomponent weights may be omitted. A final discision will be taken based on correlation analysis.\n\n>**Correlation Analysis**\n\nCorrelation measures the strength and direction of the linear relationship between independent variables (features). A correlation matrix is a common tool for examining relationships between multiple variables.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\ncorr = temp.corr()\nplt.figure(figsize = (8,8))\nax = sns.heatmap(corr, vmin = -1, center = 0, annot = True, cmap = 'mako')\n```\n\n::: {.cell-output .cell-output-display}\n![Correlation matrix of numerical features](evaluation1_files/figure-pdf/fig-cor-output-1.pdf){#fig-cor fig-pos='H'}\n:::\n:::\n\n\n@fig-cor shows the correlation matrix of the numerical features in the dataset. As expected, the subcomponents of weight of abalone shows very high correlation with the feature Whole weight, we can drop the subcomponents whithout loosing feature information. Also high coorelation found between the features, Length & Diameter. So let's find those features which shows similar pattern and to be excluded.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nupper_tri = corr.where(np.triu(np.ones(corr.shape),k=1).astype(bool))\ncolumns_to_drop = [column for column in upper_tri.columns if any(upper_tri[column] > 0.95)] #highly correlated variables to be removed.\nprint(\"Columns to drop:\\n\", columns_to_drop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nColumns to drop:\n ['Diameter', 'Shucked weight', 'Viscera weight', 'Shell weight']\n```\n:::\n:::\n\n\n>**Selection of skillful features**\n\nFrom the correlation analysis, Diameter, Shuckle weight, Viscera weight and Shell weights are redundant features. So they are dropped and further the feature Height will be normalized with square root transformation.\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\ndf.drop(columns_to_drop, axis=1, inplace = True)\n# apply square root trasnformation\ndf['Height'] = np.sqrt(df['Height'])\n```\n:::\n\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# rechecking skewness\ndf.skew().sort_values(ascending = False)\n```\n\n::: {.cell-output .cell-output-display execution_count=177}\n```\nAge             1.113754\nWhole weight    0.530549\nHeight         -0.176012\nLength         -0.640993\ndtype: float64\n```\n:::\n:::\n\n\nNow all the independent variables are near to zero skewness. Following histogram verify this observation.\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\ndf.hist(figsize = (20,10), layout = (2,4), bins = 30)\n```\n\n::: {.cell-output .cell-output-display execution_count=178}\n```\narray([[<Axes: title={'center': 'Length'}>,\n        <Axes: title={'center': 'Height'}>,\n        <Axes: title={'center': 'Whole weight'}>,\n        <Axes: title={'center': 'Age'}>],\n       [<Axes: >, <Axes: >, <Axes: >, <Axes: >]], dtype=object)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](evaluation1_files/figure-pdf/cell-55-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n>**Creation of a new categorical variables using the variable `Age`**\n\nBased on the age distribution of the Abalone in the given datset, a new categroical variable is created as follows:\n$$\n\\text{Age Group}=\\begin{cases}1&;\\quad 2.5\\leq \\text{Age}<9.5\\\\ 2&;\\quad 9.5\\leq \\text{Age}<12.5\\\\3&; \\quad 12.5\\leq \\text{Age}\\leq 30.5\\end{cases}\n$$\n\nNow the structure of the updated dataset will be as follows.\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\ndf['Age_Group'] = pd.cut(x=df['Age'], bins=[2.5,9.5,12.5,30.5],\n                     labels=['1', '2', '3'])\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=179}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Length</th>\n      <th>Height</th>\n      <th>Whole weight</th>\n      <th>Age</th>\n      <th>Age_Group</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.455</td>\n      <td>0.308221</td>\n      <td>0.5140</td>\n      <td>16.5</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.350</td>\n      <td>0.300000</td>\n      <td>0.2255</td>\n      <td>8.5</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.530</td>\n      <td>0.367423</td>\n      <td>0.6770</td>\n      <td>10.5</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.440</td>\n      <td>0.353553</td>\n      <td>0.5160</td>\n      <td>11.5</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.330</td>\n      <td>0.282843</td>\n      <td>0.2050</td>\n      <td>8.5</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nDistribution of samples over the newly created categorical variable is shown in @fig-new.\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\nsns.countplot(x='Age_Group', data=df)\n#plt.title('Distributed Classes')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Sample distribution over Age_Group.](evaluation1_files/figure-pdf/fig-new-output-1.pdf){#fig-new fig-pos='H'}\n:::\n:::\n\n\n>**MLP models for classification**\n\nNow the final data for MLP model can be created as follows. \n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# creating dataset for classification\n#Length\tHeight\tWhole weight\ndf_c = pd.concat([df['Length'], df['Height'],df['Height'],df['Whole weight'],df['Age_Group']], axis=1)\n# dataset for regression\n\ndf_r = pd.concat([df['Length'], df['Height'],df['Height'],df['Whole weight'],df['Age']], axis=1)\n```\n:::\n\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# prepare input and target from the engineered dataset\nX=df_c.drop('Age_Group', axis = 1)\n#X = df.drop('Age_Group', axis = 1)\ny = df['Age_Group']\n```\n:::\n\n\n>**Bulding MLP model**\n\nIn this section we will build an MLP model with two hidden layers for the classification job. `Python` code for this task is given below.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# loading libraries: classification mlp model for the abalone dataset\nfrom numpy import unique\nfrom numpy import argmax\nfrom pandas import read_csv\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\n```\n:::\n\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nX, y = X.astype('float'), y.astype('float')\nn_features = X.shape[1]\n# encode strings to integer\ny = LabelEncoder().fit_transform(y)\nn_class = len(unique(y))\n# split data into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=1)\n# define the keras model\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=n_features, activation='relu', kernel_initializer='he_normal'))\nmodel.add(Dense(10, activation='relu', kernel_initializer='he_normal'))\nmodel.add(Dense(n_class, activation='softmax'))\n# compile the keras model\nmodel.compile(loss='sparse_categorical_crossentropy', optimizer='adam',metrics=['accuracy'])\n# fit the keras model on the dataset\nhistory=model.fit(X_train, y_train, epochs=150, batch_size=32,validation_split=0.2, verbose=False)\n```\n:::\n\n\nModel loss and accuracy during the training and the validation is shown in @fig-Abal.\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# Plot accuracy and loss from history\nplt.figure(figsize=(8, 5))\n\n# Accuracy plot\nplt.subplot(1, 2, 1)\nplt.plot(history.history['accuracy'], label='Train Accuracy')\nplt.plot(history.history['val_accuracy'], label='Validation Accuracy')\nplt.title('Model Accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Accuracy')\nplt.legend()\n\n# Loss plot\nplt.subplot(1, 2, 2)\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.title('Model Loss')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Model loss and accuracy during training and validation.](evaluation1_files/figure-pdf/fig-abal-output-1.pdf){#fig-abal fig-pos='H'}\n:::\n:::\n\n\n>**Performance Evaluation**\n\nSkill of the MLP classification model that we built is evaluated using the measures- confusion matrix, accuracy, precision, recall, f1 score. Class-wise accuracy will be assessed using the classification report. All these measures are evaluated using the following `Python` code.\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nfrom sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score,classification_report\nyhat = model.predict(X_test)\n# Calculate confusion matrix\nyhat_class = np.argmax(yhat, axis=1)  # Predicted classes\ncm = confusion_matrix(y_test, yhat_class)\n# Calculate classification metrics\naccuracy = accuracy_score(y_test, yhat_class)\nprecision = precision_score(y_test, yhat_class, average='weighted')  # Weighted for multiclass\nrecall = recall_score(y_test, yhat_class, average='weighted')\nf1 = f1_score(y_test, yhat_class, average='weighted')\n\n# Display metrics\nprint(\"Confusion Matrix:\")\nprint(cm)\nprint(f\"Accuracy: {accuracy:.3f}\")\nprint(f\"Precision: {precision:.3f}\")\nprint(f\"Recall: {recall:.3f}\")\nprint(f\"F1 Score: {f1:.3f}\")\nprint(classification_report(y_test, yhat_class))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r 1/44 ━━━━━━━━━━━━━━━━━━━━ 2s 54ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r44/44 ━━━━━━━━━━━━━━━━━━━━ 0s 1ms/step \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r44/44 ━━━━━━━━━━━━━━━━━━━━ 0s 2ms/step\nConfusion Matrix:\n[[345 106   0]\n [124 467  25]\n [ 33 244  34]]\nAccuracy: 0.614\nPrecision: 0.611\nRecall: 0.614\nF1 Score: 0.570\n              precision    recall  f1-score   support\n\n           0       0.69      0.76      0.72       451\n           1       0.57      0.76      0.65       616\n           2       0.58      0.11      0.18       311\n\n    accuracy                           0.61      1378\n   macro avg       0.61      0.54      0.52      1378\nweighted avg       0.61      0.61      0.57      1378\n\n```\n:::\n:::\n\n\n>**Key Metrics**:\n\n- **Accuracy**: 0.622  \n  The model correctly classified 62.2% of the total samples. This indicates room for improvement in overall performance.\n\n- **Precision**: 0.610  \n  Precision reflects the proportion of true positive predictions among all positive predictions. A precision of 0.610 suggests a moderate rate of correct positive predictions.\n\n- **Recall**: 0.622  \n  Recall measures the proportion of true positives that were correctly identified. A recall of 0.622 shows the model detects positive samples moderately well.\n\n- **F1 Score**: 0.587  \n  The F1 Score, balancing precision and recall, indicates the model struggles to maintain consistency across all metrics.\n\n>*Class-wise Metrics*:\n\n| Class | Precision | Recall | F1-Score | Support |\n|-------|-----------|--------|----------|---------|\n| **0** | 0.68      | 0.78   | 0.72     | 451     |\n| **1** | 0.59      | 0.74   | 0.66     | 616     |\n| **2** | 0.54      | 0.16   | 0.24     | 311     |\n\n\n- **Class 0**: Performs relatively well with good precision and recall.\n- **Class 1**: Moderate performance but better recall indicates more correct detections for this class.\n- **Class 2**: Poor performance with low recall (16%), indicating the model struggles to detect this class.\n\n>*Overall Metrics*:\n\n| Metric         | Value |\n|-----------------|-------|\n| **Accuracy**    | 0.622 |\n| **Macro Avg**   | 0.610 |\n| **Weighted Avg**| 0.610 |\n\n- **Macro Average**: Unweighted average across classes, showing a slightly lower overall performance.\n- **Weighted Average**: Reflects class imbalance, weighting metrics by the number of samples in each class.\n\n>**Findings**:\n\n1. *Class Imbalance*: Class 2 shows significantly lower recall and F1-score, indicating difficulty in detecting samples from this class.\n2. *Misclassifications*:\n   - Many Class 2 samples are misclassified as Class 1 (223 instances).\n   - Class 0 performs better but still has notable misclassifications into Class 1.\n\n>**Conclusion**:The model performs moderately well overall but struggles with:\n\n- Detecting Class 2 effectively.\n- Managing misclassifications between Class 1 and Class 2.\n\nImproving the dataset balance, refining the model, or employing techniques like class-specific weighting or advanced algorithms could enhance the performance.\n\n----\n\n",
    "supporting": [
      "evaluation1_files\\figure-pdf"
    ],
    "filters": []
  }
}