{"title":"Assignment 1- Foundations of Deep Learning","markdown":{"yaml":{"title":"Assignment 1- Foundations of Deep Learning","jupyter":"python3"},"headingText":"Evaluation 1","containsRefs":false,"markdown":"\n\n\n\n\n```{python}\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings('ignore') # suppress warning\n```\n\n\n##  Design of a DNN from the scrtach.\n\n### Problem statement\nDesign the deep neural network based on the user input. Compute the number of learnable parameters in each layer. The design of the architecture and the number of learnable parameters must be printed. (Comments are required for the understandability of the logic behind the code. Hidden layer computation can be written as function file. Direct function available as built-in library package must not be used). \n\n----\n\n**Solution**\n\n>**Goal**\nThe goal of this problem is to design and implement an Artificial Neural Network (ANN) from scratch using Object-Oriented Programming (OOP) principles. The implementation should allow users to create an instance of the `model`, add `layers` in a manner similar to `Keras`, and finally call a `summary()` method to print the architecture and the number of learnable parameters. The project should also include the implementation of a Dropout layer to help prevent overfitting.\n\n>**Objectives**\n\n\n1. *Design an OOP Architecture:* Develop a clear and flexible OOP architecture for building and managing neural networks. This architecture should include base classes and specific layer classes such as `Dense` and `Dropout`.\n2. *Implement Layer Classes:* Implement the `Dense` and `Dropout layer classes, including methods to compute the number of learnable parameters and perform the forward pass.\n3. *Create a Neural Network Class:* Implement a NeuralNetwork class that allows users to add layers, compute the total number of parameters, perform the forward pass, and print the summary of the model.\n4. *Include Dropout Functionality:* Implement the Dropout layer to randomly set a fraction of input units to 0 during training and scale the remaining units to maintain the expected value.\n4. *Provide User-Friendly Interface:* Ensure that the user can create an instance of the model, add layers in a manner similar to Keras, and call `model.summary()` to print the architecture and the number of learnable parameters.\n\n>**Deliverables**\n\n-  *Source Code:* The complete source code for the ANN implementation, including the Layer, Dense, Dropout, and NeuralNetwork classes.\n- *Demonstration:* A script demonstrating how to create an instance of the model, add layers, and call model.summary() to print the architecture and the number of learnable parameters.\n- *Documentation:* A detailed description of the OOP architecture, explaining the role and functionality of each class and how they work together to achieve the goal of designing an ANN.\n\nThe following source code should include the design and  implementation of the Layer, Dense, Dropout, and NeuralNetwork classes required for an ANN architecture.\n\n*Note:* The Dropout class is implemented the dropout functionality as described by Andrew Ng^[<https://github.com/ashishpatel26/Andrew-NG-Notes/blob/master/andrewng-p-2-improving-deep-learning-network.md#dropout-regularization>].\n\n\n>**Description of the OOP Architecture for Designing an Artificial Neural Network**\n\nThe provided code implements an Artificial Neural Network (ANN) using Object-Oriented Programming (OOP) principles. The architecture is designed to allow users to create an instance of the model, add layers in a manner similar to Keras, and finally call `model.summary()` to print the architecture and the number of learnable parameters. The key components of this architecture are the `Layer`, `Dense`, `Dropout`, and `NeuralNetwork` classes. For this design only the `NumPy` library is used for numerical computations involved in model parameter calculations.\n\n>**OOPs Architecture- Block diagram**\n\n::: {#fig-OOP}\n```{mermaid}\nclassDiagram\n    class Layer {\n        +int params\n        +forward(x, training=True)\n        +compute_params() int\n    }\n\n    class Activation {\n        +string activation\n        +validate_activation()\n        +forward(x, training=True)\n    }\n\n    class Dense {\n        +int input_units\n        +int output_units\n        +array weights\n        +array biases\n        +Activation activation\n        +compute_params() int\n        +forward(x, training=True)\n    }\n\n    class Dropout {\n        +float rate\n        +forward(x, training=True)\n    }\n\n    class NeuralNetwork {\n        +tuple input_shape\n        +list layers\n        +add(layer)\n        +compute_total_params() int\n        +forward(x, training=True)\n        +summary()\n    }\n\n    Layer <|-- Activation\n    Layer <|-- Dense\n    Layer <|-- Dropout\n    NeuralNetwork \"1\" *-- \"many\" Layer\n```\n\nBlock diagram of OOP approach used in the proposed ANN architecture.\n\n:::\n\nA block diagram illustrating the OOP architecture of the proposed ANN model is shown in Figure @fig-OOP.\n\n```{python}\n# importing NumPy instance\nimport numpy as np\n```\n\n>*Layer Class*:\nThe Layer class serves as a base class for all layers in the neural network. It includes methods to compute the number of parameters and perform the forward pass. This class is designed to be inherited by specific layer types such as Dense and Dropout.\n\n*Attributes:*\n\n- `params`: Stores the number of learnable parameters in the layer.\nMethods:\n\n- `compute_params()`: Returns the number of learnable parameters.\n\n- `forward(x, training=True)`: Placeholder method for the forward pass, to be implemented by subclasses.\n\n```{python}\n# defintion of the layer class (super class)\nclass Layer:\n    def __init__(self):\n        self.params = 0\n\n    def forward(self, x, training=True):\n        raise NotImplementedError\n\n    def compute_params(self):\n        return self.params\n```\n\n>*Activation Class:* Implements different activation functions such as `sigmoid`, `relu`, and `softmax`.\n\n*Attributes*:\n- `activation`: The type of activation function to use.\nMethods:\n- `forward(x, training=True)`: Applies the specified activation function to the input.\n\n```{python}\n# defining the Activation class and its methods\nclass Activation(Layer):\n    def __init__(self, activation):\n        super().__init__()\n        self.activation = activation\n        self.validate_activation()\n\n    def validate_activation(self):\n        supported_activations = ['sigmoid', 'relu', 'softmax']\n        if self.activation not in supported_activations:\n            raise ValueError(f\"Unsupported activation function: {self.activation}. Supported activations are: {supported_activations}\")\n\n    def forward(self, x, training=True):\n        if self.activation == 'sigmoid':\n            return 1 / (1 + np.exp(-x))\n        elif self.activation == 'relu':\n            return np.maximum(0, x)\n        elif self.activation == 'softmax':\n            exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n            return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n```\n\n>*Dense Class:*\nThe Dense class inherits from the Layer class and implements a fully connected (dense) layer. It includes the computation of the number of parameters and the forward pass.\n\n*Attributes*:\n\n- `input_units`: Number of input units to the layer.\n- `output_units`: Number of output units from the layer.\n- `weights`: Weight matrix of the layer, initialized with random values.\n- `biases`: Bias vector of the layer, initialized with random values.\n\n*Methods*:\n\n- `compute_params()`: Computes and returns the number of learnable parameters (weights and biases).\n- `forward(x, training=True)`: Implements the forward pass by performing a matrix multiplication of the input with the weights and adding the biases.\n\n```{python}\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, activation=None):\n        super().__init__()\n        self.input_units = input_units\n        self.output_units = output_units\n        self.weights = np.random.randn(output_units, input_units)\n        self.biases = np.random.randn(output_units)\n        self.activation = Activation(activation) if activation else None\n        self.params = self.compute_params()\n\n    def compute_params(self):\n        weight_params = self.input_units * self.output_units\n        bias_params = self.output_units\n        return weight_params + bias_params\n\n    def forward(self, x, training=True):\n        z = np.dot(self.weights, x) + self.biases\n        if self.activation:\n            return self.activation.forward(z, training)\n        return z\n```\n\n>*Dropout Class:*\nThe Dropout class inherits from the Layer class and implements a dropout layer. Dropout is a regularization technique that helps prevent overfitting by randomly setting a fraction of input units to 0 during training.\n\n*Attributes*:\n\n- `rate`: Dropout rate, representing the fraction of input units to be dropped.\n\n*Method*:\n\n- `forward(x, training=True)`: Implements the forward pass. During training, it randomly sets a fraction of input units to 0 and scales the remaining units to maintain the expected value.\n\n```{python}\n# defintion of Dropout class and its methods\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def forward(self, x, training=True):\n        if training:\n            keep_prob = 1 - self.rate\n            mask = np.random.rand(*x.shape) < keep_prob\n            x = np.multiply(x, mask)\n            x = x / keep_prob\n        return x\n```\n\n>*NeuralNetwork Class:*\nThe NeuralNetwork class represents the entire neural network. It allows users to add layers, compute the total number of parameters, perform the forward pass, and print the summary of the model.\n\n*Attributes:*\n\n- `input_shape`: Shape of the input data.\n- `layers`: List of layers in the neural network.\n\n*Methods*:\n\n- `add(layer)`: Adds a layer to the network.\n- `compute_total_params()`: Computes and returns the total number of learnable parameters in the network by summing the parameters of each layer.\n- `forward(x, training=True)`: Performs the forward pass through the network by sequentially passing the input through each layer.\n- `summary()`: Prints the architecture and the number of learnable parameters for each layer, as well as the total number of parameters.\n\n```{python}\n\n# defining the NeuralNetwork class and its methods\n\nclass NeuralNetwork:\n    def __init__(self, input_shape):\n        self.input_shape = input_shape\n        self.layers = []\n\n    def add(self, layer):\n        self.layers.append(layer)\n\n    def compute_total_params(self):\n        total_params = 0\n        for layer in self.layers:\n            total_params += layer.compute_params()\n        return total_params\n\n    def forward(self, x, training=True):\n        for layer in self.layers:\n            x = layer.forward(x, training)\n        return x\n\n    def summary(self):\n        print(\"Neural Network Summary\")\n        for layer in self.layers:\n            if isinstance(layer, Dense):\n                activation = layer.activation.activation if layer.activation else 'None'\n                print(f\"Dense Layer: Units={layer.output_units}, Activation={activation}, Params={layer.compute_params()}\")\n            elif isinstance(layer, Dropout):\n                print(f\"Dropout Layer: Rate={layer.rate}\")\n        print(f\"Total Parameters: {self.compute_total_params()}\")\n```\n\n>**Demonstration**\n\nThe example usage demonstrates how to create an instance of the `NeuralNetwork` class, `add layers` to the `model`, and call `model.summary()` to print the architecture and the number of learnable parameters.\n\n```{python}\n# Example usage\ninput_shape = (784,)  # Example input shape for MNIST dataset (28x28 images flattened)\n\n# Create the model with input layer\nmodel = NeuralNetwork(input_shape)\n# Add first hidden layer with 128 neurons and relu activation to the model\nmodel.add(Dense(input_shape[0], 128, activation='relu'))\n# Add dropout layer with rate 0.5\nmodel.add(Dropout(0.5))\n# Add second hidden layer with 64 neurons and relu activation to the model\nmodel.add(Dense(128, 64, activation='relu'))\n# Add dropout layer with rate 0.5\nmodel.add(Dropout(0.5))\n# Add output layer with 10 neurons and softmax activation for 10 class classification\nmodel.add(Dense(64, 10, activation='softmax'))  # Output layer for 10 classes\n# Print the summary of the model\nmodel.summary()\n```\n\n>**Complete implementation**\n\n```{python}\nimport numpy as np\n\nclass Layer:\n    def __init__(self):\n        self.params = 0\n\n    def forward(self, x, training=True):\n        raise NotImplementedError\n\n    def compute_params(self):\n        return self.params\n\nclass Activation(Layer):\n    def __init__(self, activation):\n        super().__init__()\n        self.activation = activation\n        self.validate_activation()\n\n    def validate_activation(self):\n        supported_activations = ['sigmoid', 'relu', 'softmax']\n        if self.activation not in supported_activations:\n            raise ValueError(f\"Unsupported activation function: {self.activation}. Supported activations are: {supported_activations}\")\n\n    def forward(self, x, training=True):\n        if self.activation == 'sigmoid':\n            return 1 / (1 + np.exp(-x))\n        elif self.activation == 'relu':\n            return np.maximum(0, x)\n        elif self.activation == 'softmax':\n            exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n            return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n\n\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, activation=None):\n        super().__init__()\n        self.input_units = input_units\n        self.output_units = output_units\n        self.weights = np.random.randn(output_units, input_units)\n        self.biases = np.random.randn(output_units)\n        self.activation = Activation(activation) if activation else None\n        self.params = self.compute_params()\n\n    def compute_params(self):\n        weight_params = self.input_units * self.output_units\n        bias_params = self.output_units\n        return weight_params + bias_params\n\n    def forward(self, x, training=True):\n        z = np.dot(self.weights, x) + self.biases\n        if self.activation:\n            return self.activation.forward(z, training)\n        return z\n\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def forward(self, x, training=True):\n        if training:\n            keep_prob = 1 - self.rate\n            mask = np.random.rand(*x.shape) < keep_prob\n            x = np.multiply(x, mask)\n            x = x / keep_prob\n        return x\n\nclass NeuralNetwork:\n    def __init__(self, input_shape):\n        self.input_shape = input_shape\n        self.layers = []\n\n    def add(self, layer):\n        self.layers.append(layer)\n\n    def compute_total_params(self):\n        total_params = 0\n        for layer in self.layers:\n            total_params += layer.compute_params()\n        return total_params\n\n    def forward(self, x, training=True):\n        for layer in self.layers:\n            x = layer.forward(x, training)\n        return x\n\n    def summary(self):\n        print(\"Neural Network Summary\")\n        for layer in self.layers:\n            if isinstance(layer, Dense):\n                activation = layer.activation.activation if layer.activation else 'None'\n                print(f\"Dense Layer: Units={layer.output_units}, Activation={activation}, Params={layer.compute_params()}\")\n            elif isinstance(layer, Dropout):\n                print(f\"Dropout Layer: Rate={layer.rate}\")\n        print(f\"Total Parameters: {self.compute_total_params()}\")\n\n# Example usage\ninput_shape = (784,)  # Example input shape for MNIST dataset (28x28 images flattened)\n\n# Create the model\nmodel = NeuralNetwork(input_shape)\n\n# Add layers to the model\nmodel.add(Dense(input_shape[0], 128, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, 64, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, 64, activation='relu'))\n\nmodel.add(Dense(64, 10, activation='softmax'))  # Output layer for 10 classes\n\n# Print the summary of the model\nmodel.summary()\n```\n\n----\n\n## Popular Activation Functions in Deep Learning\n\n### Problem statement\n\nExplore atleast 3 different activation functions used in the deep learning. Present the mathematical equation (with all variables defined) and plot the same.\n\n**Solution:**\n\n>1. *Sigmoid Activation Function:*\nThe Sigmoid activation function is defined as: $$\\sigma(x) = \\dfrac{1}{1 + e^{-x}}$$\n\n- As  $x \\to -\\infty$, $\\sigma(x) \\to 0$.\n- As $x \\to +\\infty$, $\\sigma(x) \\to 1$.\n- The curve smoothly transitions from 0 to 1, creating an \"S\" shape.\n\n>**Properties**\n\n- *S-shape*: The function's smooth curve has two asymptotes (at 0 and 1), creating the S-like appearance.\n- *Monotonic*: Always increasing.\n- *Differentiable*: Smooth changes without sharp edges.\n- *Derivative*: $\\sigma'(x)=\\sigma(x)\\left(1-\\sigma(x)\\right)$\n\n*Graph:* Graph of the sigmoid function is plotted as shown in @fig-sigmoid:\n\n```{python}\n#| label: fig-sigmoid\n#| fig-cap: \"Graph of sigmoid activation function\"\n\n# importing libraries for numerical computation and plotting\nimport numpy as np\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\nx = np.linspace(-10, 10, 400)\ny = sigmoid(x)\n\nplt.plot(x, y)\nplt.title('$\\sigma(x)=\\dfrac{1}{1+e^{-x}}$')\nplt.xlabel('Input (x)')\nplt.ylabel('Output ($\\sigma(x)$)')\nplt.grid(True)\nplt.show()\n```\n\n>2. *Rectified Linear Units (ReLu)*\n\nThe ReLU activation function is defined as: $$\\text{ReLU}(x) = \\max(0, x)=\\begin{cases}x&;\\quad x\\geq 0\\\\ 0&;\\quad x<0\\end{cases}$$\n\n$\\implies$\n- For $x < 0$, $\\text{ReLU}(x) = 0$.\n- For $x \\geq 0$, $\\text{ReLU}(x) = x$.\n\n*Why \"Rectified\"?*\n\n- The term *\"rectified\"* comes from the fact that the function \"corrects\" or \"rectifies\" the negative inputs by mapping them to 0 while leaving positive inputs unchanged.\n\n*Properties*:\n\n- *Simple*: Computationally efficient due to its straightforward implementation.\n- *Non-linear capability*: Despite its linear segment, it allows for non-linear transformations when combined in networks.\n- *Sparsity*: Outputs zero for all negative inputs, introducing sparsity in neural network activations.\n\n```{python}\n#| label: fig-relu\n#| fig-cap: \"Graph of ReLu activation function\"\ndef relu(x):\n    return np.maximum(0, x)\n\ny = relu(x)\n\nplt.plot(x, y)\nplt.title('ReLU Activation Function')\nplt.xlabel('Input (x)')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>3. *Softmax Activation Function*\n\n$$\n\\sigma(z_i) = \\frac{e^{z_i}}{\\sum\\limits_{j=1}^{n} e^{z_j}} \\quad \\text{for } i = 1, \\dots, n\n$$\n\n- $z_i$ is the $i$-th element of the input vector $z$.\n- $e^{z_i}$ ensures all outputs are positive.\n- The sum of all outputs equals 1, making them suitable as probabilities.\n\n*Properties*:\n\n- *Probabilistic Output*: Transforms raw scores into probabilities, with outputs summing to 1.\n- *Sensitivity*: Exponentiation amplifies the relative differences between inputs.\n- *Differentiability*: Unlike argmax, Softmax is differentiable, making it usable in optimization.\n\n```{python}\n#| label: fig-softmax\n#| fig-cap: \"Graph of softmax activation function\"\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x))\n    return exp_x / np.sum(exp_x)\n\nx = np.linspace(-2, 2, 400)\ny = softmax(x)\n\nplt.plot(x, y)\nplt.title('Softmax Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>4. *Leaky ReLu*\n\nThe name *Leaky ReLU* derives from the function's behavior, which is a variant of the *Rectified Linear Unit (ReLU)* activation function. Unlike ReLU, which sets all negative inputs to $0$, Leaky ReLU introduces a *small, non-zero gradient* ($\\alpha$) for negative inputs.This allows some information to \"leak\" through even when the input is negative.\n\nThe Leaky ReLU function is defined as:\n\n$$\nf(x) =\n\\begin{cases}\nx & \\text{if } x \\geq 0 \\\\\n\\alpha x & \\text{if } x < 0\n\\end{cases}\n$$\n\n- $x$ is the input to the function.\n- $\\alpha$ is a small positive constant, often chosen as 0.01, which defines the \"leakiness.\"\n\n*Properties*:\n\n- *Non-zero Gradient for Negative Inputs*: Solves the *dying ReLU problem*, where neurons become inactive due to zero gradients.\n- *Linear for Positive Values*: Retains simplicity and efficiency of ReLU for non-negative inputs.\n- *Parameter $\\alpha$*: Can be set manually or learned during training.\n\n```{python}\n#| label: fig-leakyrelu\n#| fig-cap: \"Graph of Leaky ReLu activation function\"\ndef leaky_relu(x, alpha=0.01):\n    return np.where(x >= 0, x, alpha * x)\n\nx = np.linspace(-10, 10, 400)\ny = leaky_relu(x)\n\nplt.plot(x, y)\nplt.title('Leaky ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>5. *ELU (Exponential Linear Unit)* Activation Function\n\nThe name *ELU* reflects the combination of its two defining characteristics: *Exponential* behavior for negative inputs and a *Linear Unit* for positive inputs.\n$$\nf(x) =\n\\begin{cases}\nx & \\text{if } x > 0 \\\\\n\\alpha (e^x - 1) & \\text{if } x \\leq 0\n\\end{cases}\n$$\n\n*Properties*:\n\n- *Smooth Transition*: ELU is continuous and differentiable, with a smooth gradient that helps optimization during training.\n- *Non-zero Gradient for Negative Inputs*: Unlike ReLU, which outputs zero for negative inputs, ELU introduces a small gradient for $x \\leq 0$, mitigating the *dying ReLU problem*.\n- *Output Range*: Negative outputs are bounded by $-\\alpha$, introducing a degree of normalization.\n- *Linear Behavior for Positive Inputs*: Ensures fast convergence and efficient representation for positive values.\n\n```{python}\n#| label: fig-elu\n#| fig-cap: \"Graph of Exponential ReLu activation function\"\ndef elu(x, alpha=1.0):\n    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))\n\ny = elu(x)\n\nplt.plot(x, y)\nplt.title('ELU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>6. *$\\tanh(x)$ activation function*\n\nThe name *Tanh* comes from the *Hyperbolic Tangent* function, which is defined mathematically as:\n\n$$\n\\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)} = \\frac{e^x - e^{-x}}{e^x + e^{-x}}\n$$\n\n*Properties*:\n\n-  *Range*: $\\tanh(x)$ maps input values to the range $(-1, 1)$.\n-  *Zero-centered Output*: Unlike the sigmoid function, $\\tanh(x)$ outputs values symmetrically around zero, making it more effective for training neural networks as it reduces bias in gradient updates.\n-  *Non-linearity*: Provides a smooth and non-linear transformation of the input.\n-  *Gradient*: The derivative of $\\tanh(x)$ is:\n   $$\n   \\frac{d}{dx}\\tanh(x) = 1 - \\tanh^2(x)\n   $$\n\n```{python}\n#| label: fig-tanh\n#| fig-cap: \"Graph of Exponential tanh activation function\"\ndef tanh(x):\n    return np.tanh(x)\n\ny = tanh(x)\n\nplt.plot(x, y)\nplt.title('Tanh Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>*Comparison: $\\tanh(x)$ vs. Sigmoid*\n\n| Feature                     | $\\tanh(x)$                                    | $Sigmoid$                                     |\n|-----------------------------|------------------------------------------------|---------------------------------------------|\n| **Range**                   | $(-1, 1)$                                   | $(0, 1)$                                  |\n| **Zero-centered Output**    | Yes                                           | No                                          |\n| **Gradient**                | Steeper than sigmoid, improving convergence    | Can saturate for extreme values ( $\\pm x$ ) |\n| **Formula**                 | $\\frac{e^x - e^{-x}}{e^x + e^{-x}}$          | $\\frac{1}{1 + e^{-x}}$                    |\n| **Bias in Updates**         | No (zero-centered output)                      | Yes (output always positive)                |\n| **Usage**                   | Preferred in deep networks for faster training | Often used in output layers for probabilities|\n\n\nA visual comparison of all the activation functions together is shown in @fig-comp.\n\n```{python}\n#| label: fig-comp\n#| fig-cap: \"Visual comparionn of popular activation functions\"\n# Sigmoid Activation Function\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\n# ReLU Activation Function\ndef relu(x):\n    return np.maximum(0, x)\n\n# Softmax Activation Function\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x))\n    return exp_x / np.sum(exp_x)\n\n# Leaky ReLU Activation Function\ndef leaky_relu(x, alpha=0.01):\n    return np.where(x >= 0, x, alpha * x)\n\n# ELU Activation Function\ndef elu(x, alpha=1.0):\n    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))\n\n# Tanh Activation Function\ndef tanh(x):\n    return np.tanh(x)\n\n# Plotting the activation functions\nx = np.linspace(-10, 10, 400)\n\nplt.figure(figsize=(12, 8))\n\n# Sigmoid\nplt.subplot(2, 3, 1)\nplt.plot(x, sigmoid(x))\nplt.title('Sigmoid Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# ReLU\nplt.subplot(2, 3, 2)\nplt.plot(x, relu(x))\nplt.title('ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Softmax\nplt.subplot(2, 3, 3)\nplt.plot(x, softmax(x))\nplt.title('Softmax Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Leaky ReLU\nplt.subplot(2, 3, 4)\nplt.plot(x, leaky_relu(x))\nplt.title('Leaky ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# ELU\nplt.subplot(2, 3, 5)\nplt.plot(x, elu(x))\nplt.title('ELU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Tanh\nplt.subplot(2, 3, 6)\nplt.plot(x, tanh(x))\nplt.title('Tanh Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n\n## Comparison of Activation Functions\n\n| Activation Function | Properties | Strengths | Weaknesses |\n|---------------------|------------|-----------|------------|\n| **Sigmoid**         | S-shaped curve, outputs range (0, 1) | Smooth gradient, outputs can be interpreted as probabilities | Vanishing gradient problem, slow convergence |\n| **Softmax**         | Generalization of sigmoid, outputs sum to 1 | Useful for multi-class classification, outputs probabilities | Computationally expensive, can be sensitive to outliers |\n| **ReLU (Rectified Linear Unit)** | Outputs zero for negative inputs, linear for positive inputs | Computationally efficient, mitigates vanishing gradient problem | Can suffer from \"dying ReLU\" problem where neurons become inactive |\n| **Leaky ReLU**      | Similar to ReLU, but allows a small gradient for negative inputs | Prevents \"dying ReLU\" problem, retains benefits of ReLU | Introduces a small bias in the model |\n| **Exponential ReLU (ELU)** | Similar to ReLU, but smooths the curve for negative inputs | Reduces bias shift, faster learning | Computationally more expensive, can still suffer from vanishing gradient |\n| **Tanh**            | S-shaped curve, outputs range (-1, 1) | Zero-centered outputs, stronger gradients than sigmoid | Vanishing gradient problem, slower convergence compared to ReLU |\n\n\n---- \n\n\n## Solution of real world problems using MLP\n\n\nIdentify a dataset and build your own deep neural network architecture for the following:\n\n1. Regression                                                         \n2. Classification (multi-class).\n\n*Note:* Built-in library packages can be used to implement this question. Plot the loss curves. Print the performance evaluation measures.\n\n**Solution**\n\n\n### Task 1: Regression Model\n\n>**Task 1: Stock market prediction**\n\n>**Problem Statement:**\n\nThe goal of this task is to predict the future Apple stock price (Close price) based on historical stock market data over a four-year period. The data includes various financial indicators and technical analysis features, such as stock opening, closing, and volume, along with moving averages, exponential moving averages (EMA), relative strength index (RSI), force index, and other financial market indicators.\n\nThe dataset contains the following features:\n\n**Stock Data Columns:**\n\n- **Open**, **High**, **Low**, **Close**, **Volume**: Basic stock market data representing the price points and volume for Apple stock.\n  \n**Technical Indicators:**\n\n- **SD20**, **Upper_Band**, **Lower_Band**: Bollinger Bands indicators based on the 20-day standard deviation.\n- **S_Close(t-1)**, **S_Close(t-2)**, **S_Close(t-3)**, **S_Close(t-5)**: Lagged closing prices.\n- **S_Open(t-1)**: Lagged opening price.\n- **MA5**, **MA10**, **MA20**, **MA50**, **MA200**: Moving averages of the closing prices over different time intervals.\n- **EMA10**, **EMA20**, **EMA50**, **EMA100**, **EMA200**: Exponential moving averages for different periods.\n- **MACD**, **MACD_EMA**: Moving Average Convergence Divergence and its exponential moving average.\n- **ATR**: Average True Range, measuring market volatility.\n- **ADX**: Average Directional Index, used to determine the strength of a trend.\n- **CCI**: Commodity Channel Index, used to identify cyclical trends.\n- **ROC**: Rate of Change, measuring the percentage change in price.\n- **RSI**: Relative Strength Index, an oscillator that measures the speed and change of price movements.\n- **William%R**: Williams %R, a momentum indicator.\n- **SO%K**: Stochastic Oscillator %K.\n- **STD5**: Standard deviation over the past 5 days.\n- **ForceIndex1**, **ForceIndex20**: Force index, a volume-based indicator of price movement.\n\n**Market Indices Data:**\n\n- **QQQ_Close**, **QQQ(t-1)**, **QQQ(t-2)**, **QQQ(t-5)**: Historical data for the QQQ index.\n- **SnP_Close**, **SnP(t-1)**, **SnP(t-5)**: Historical data for the S&P 500 index.\n- **DJIA_Close**, **DJIA(t-1)**, **DJIA(t-5)**: Historical data for the DJIA index.\n\n**Time-based Features:**\n\n- **Date_col**: Date of the record.\n- **Day**, **DayofWeek**, **DayofYear**, **Week**: Time-based features of the day and year.\n- **Is_month_end**, **Is_month_start**, **Is_quarter_end**, **Is_quarter_start**, **Is_year_end**, **Is_year_start**, **Is_leap_year**: Categorical features indicating various time period markers.\n\nThe task is to build a model that can forecast the **Apple stock price (Close)** for a given future period based on the historical data and technical indicators. The model should leverage time series data, stock market indicators, and macroeconomic factors to predict stock price movements accurately.\n\n**Objectives:**\n\n1. Preprocess the data to handle missing values, scale features, and engineer any additional features if required.\n2. Develop and train machine learning models to predict the Apple stock price using historical data and technical indicators.\n3. Evaluate model performance using appropriate metrics such as Mean Absolute Error (MAE), Mean Squared Error (MSE), and R-squared ($R^2$).\n4. Provide insights into which features are most influential in predicting the Apple stock price.\n\nThe model will be evaluated on its ability to predict the **`Close_forcast`** column, which represents the future Apple stock closing price.\n\n**Expected Outcome:**\n\nThe output will be a reliable regression model capable of forecasting the Apple stock price with acceptable accuracy based on historical trends and technical analysis features.\n\n----\n\nSolution procedure of this task is explained in detail if following section.\n\n>**Step 1: Loading necessary libraries and dataset**\n\n```{python}\nimport pandas as pd # for dataset handling\nimport numpy as np # for numerical computations\n# libraries for ML preprocessing and model performance evaluation tasks\nfrom sklearn.model_selection import cross_val_score, train_test_split\n#from sklearn.feature_selection import RFECV, SelectFromModel, SelectKBest\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import metrics\n%matplotlib inline\n```\n\nA close look at the structure of the data is shown below.\n\n```{python}\nStock = pd.read_csv('https://raw.githubusercontent.com/sijuswamyresearch/24DS611-DL/refs/heads/main/AAPL.csv',  index_col=0)\ndf_Stock = Stock\ndf_Stock = df_Stock.rename(columns={'Close(t)':'Close'})\ndf_Stock.head()\n```\n\nTotal number of features and sample size can be found using the following `python` code.\n\n```{python}\ndf_Stock.shape\n```\n\nFeatures and target in the data set is shown below.\n\n```{python}\ndf_Stock.columns\n```\n\nUsing the native `pandas` `plot`function, the target variable can be visualized as shown in @fig-datav. In the current study only a multiple linear regression model is designed without considering the time series properties of the data.\n\n```{python}\n#| label: fig-datav\n#| fig-cap: \"Apple stock price from the given data\"\ndf_Stock['Close'].plot(figsize=(10, 7))\nplt.title(\"Stock Price\", fontsize=17)\nplt.ylabel('Price', fontsize=14)\nplt.xlabel('Time', fontsize=14)\nplt.grid(which=\"major\", color='k', linestyle='-.', linewidth=0.5)\nplt.show()\n```\n\nFor the MLP model, we are considering only the numerical features available in the dataset. So the date column is dropped as follows.\n\n```{python}\ndf_Stock = df_Stock.drop(columns='Date_col')\n```\n\nIn this work we are using the `Keras` library with Tensorflow backend as the source for basic DNN design and implementations. As usual the pupular ML library `scikitlearn` and its functions will be used for data preparation, scaling and model evaluation. Required methods for model building, compliling and performance evaluation can be loaded as follows.\n\n```{python}\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom sklearn.metrics import mean_squared_error, r2_score\n```\n\nTwo functions will be used for model design, implementation and evaluation.\n\n```{python}\n# Function to create train, validation, and test sets\ndef create_train_test_set(df_Stock):\n    features = df_Stock.drop(columns=['Close_forcast'], axis=1)\n    target = df_Stock['Close_forcast']\n\n    # Normalizing features\n    scaler = StandardScaler()\n    features_scaled = scaler.fit_transform(features)\n\n    # Splitting the dataset\n    X_train, X_temp, Y_train, Y_temp = train_test_split(features_scaled, target, test_size=0.12, random_state=42)\n    X_val, X_test, Y_val, Y_test = train_test_split(X_temp, Y_temp, test_size=0.5, random_state=42)\n\n    return X_train, X_val, X_test, Y_train, Y_val, Y_test, scaler\n\nX_train, X_val, X_test, Y_train, Y_val, Y_test, scaler = create_train_test_set(df_Stock)\n```\n\n```{python}\n# Define MLP model architecture\ndef create_mlp_model(input_dim):\n    model = Sequential()\n    model.add(Dense(64, input_dim=input_dim, activation='relu'))\n    model.add(Dense(32, activation='relu'))\n    model.add(Dense(16, activation='relu'))\n    model.add(Dense(16, activation='relu'))\n    model.add(Dense(1))\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    return model\n```\n\n```{python}\n# Evaluate the model\ndef evaluate_model(model, X_train, Y_train, X_val, Y_val, X_test, Y_test):\n    Y_train_pred = model.predict(X_train)\n    Y_val_pred = model.predict(X_val)\n    Y_test_pred = model.predict(X_test)\n\n\n    print(\"Training MSE:\", mean_squared_error(Y_train, Y_train_pred))\n    print(\"Validation MSE:\", mean_squared_error(Y_val, Y_val_pred))\n    print(\"Test MSE:\", mean_squared_error(Y_test, Y_test_pred))\n\n    print(\"Training R-squared:\", r2_score(Y_train, Y_train_pred))\n    print(\"Validation R-squared:\", r2_score(Y_val, Y_val_pred))\n    print(\"Test R-squared:\", r2_score(Y_test, Y_test_pred))\n```\n\nNow let's buld the model and train using previously defined functions as follows.\n\n```{python}\n# Create and train the MLP model\nmodel = create_mlp_model(X_train.shape[1])\nhistory = model.fit(X_train, Y_train, validation_data=(X_val, Y_val), epochs=60, batch_size=16, verbose=False)\n```\n\n\nNow let's evaluate the regression model using the `evaluate_model` function as follows.\n\n```{python}\nevaluate_model(model, X_train, Y_train, X_val, Y_val, X_test, Y_test)\n```\nThe model loss during training and validation is plotted using following code.\n\n```{python}\n#| label: fig-lossplot\n#| fig-cap: \"Distribution of loss function during training and validation\"\n# Plot training and validation loss\nplt.plot(history.history['loss'], label='train')\nplt.plot(history.history['val_loss'], label='validation')\nplt.title('Model Loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()\n```\n\n>**Conclusion**\n\nThe MLP regression model demonstrates excellent performance with high R-squared values (Training: 0.9990, Validation: 0.9988, Test: 0.9993) and relatively low MSE values (Training: 6.33, Validation: 6.37, Test: 4.64) across all datasets. The slight increase in validation MSE compared to training MSE suggests minimal overfitting, indicating that the model has learned the underlying patterns in the training data without capturing too much noise. The lower test MSE further confirms that the model generalizes well to unseen data, which is a positive indicator of its robustness.\n\nThe high R-squared values across training, validation, and test datasets suggest that the model has a low bias, effectively capturing the complexity of the data. The minimal difference between training and validation metrics indicates low variance, meaning the model's performance is consistent across different datasets. Overall, the model is neither underfitting nor overfitting, striking a good balance between bias and variance, and is well-suited for making accurate predictions on new data.\n\n>**Analysing the skill of the model**\n\nTo check the prediction quality of the model,we need to predict the stock price for a particular input. For these purpose we need to create an input data that is in the form of a dataframe containing all the input features. This is done in the next code cell.\n\n```{python}\n# Feature names used during training\nfeature_names= [\n    'Open', 'High', 'Low','Close', 'Volume', 'SD20', 'Upper_Band', 'Lower_Band',\n    'S_Close(t-1)', 'S_Close(t-2)', 'S_Close(t-3)', 'S_Close(t-5)', 'S_Open(t-1)',\n    'MA5', 'MA10', 'MA20', 'MA50', 'MA200', 'EMA10', 'EMA20', 'EMA50', 'EMA100', 'EMA200',\n    'MACD', 'MACD_EMA', 'ATR', 'ADX', 'CCI', 'ROC', 'RSI', 'William%R', 'SO%K', 'STD5',\n    'ForceIndex1', 'ForceIndex20', 'Day', 'DayofWeek', 'DayofYear', 'Week',\n    'Is_month_end', 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start',\n    'Is_year_end', 'Is_year_start', 'Is_leap_year', 'Year', 'Month',\n    'QQQ_Close', 'QQQ(t-1)', 'QQQ(t-2)', 'QQQ(t-5)', 'QQQ_MA10', 'QQQ_MA20', 'QQQ_MA50',\n    'SnP_Close', 'SnP(t-1))', 'SnP(t-5)', 'DJIA_Close', 'DJIA(t-1))', 'DJIA(t-5)'\n]\n\n# Provided values for input features as a dictionary.\ncustom_input_values = {\n    'Open': 7.02,\n    'High': 7.03,\n    'Low': 6.83,\n    'Close':6.87,\n    'Volume': 199181500,\n    'SD20': 0.216680094,\n    'Upper_Band': 6.974860188,\n    'Lower_Band': 6.108139812,\n    'S_Close(t-1)': 6.93,\n    'S_Close(t-2)': 6.78,\n    'S_Close(t-3)': 6.45,\n    'S_Close(t-5)': 6.67,\n    'S_Open(t-1)': 6.72,\n    'MA5': 6.726,\n    'MA10': 6.56,\n    'MA20': 6.5415,\n    'MA50': 6.209,\n    'MA200': 5.20315,\n    'EMA10': 6.760108607,\n    'EMA20': 6.760108607,\n    'EMA50': 6.760108607,\n    'EMA100': 6.760108607,\n    'EMA200': 6.760108607,\n    'MACD': 0.153339954,\n    'MACD_EMA': 0.129844817,\n    'ATR': 0.24109363,\n    'ADX': 22.06352634,\n    'CCI': 1333.333333,\n    'ROC': 8.530805687,\n    'RSI': 60.683333,\n    'William%R': -14.28571429,\n    'SO%K': 85.71428571,\n    'STD5': 0.030047679,\n    'ForceIndex1': -11950890,\n    'ForceIndex20': 59754450,\n    'Day': 21,\n    'DayofWeek': 4,\n    'DayofYear': 294,\n    'Week': 42,\n    'Is_month_end': 0,\n\n    'Is_month_start': 0,\n    'Is_quarter_end': 0,\n    'Is_quarter_start': 0,\n    'Is_year_end': 0,\n    'Is_year_start': 0,\n    'Is_leap_year': 0,\n    'Year': 2005,\n    'Month': 10,\n    'QQQ_Close': 33.98,\n    'QQQ(t-1)': 33.77,\n    'QQQ(t-2)': 34.09,\n    'QQQ(t-5)': 33.55,\n    'QQQ_MA10': 33.586,\n    'QQQ_MA20': 33.9365,\n    'QQQ_MA50': 34.2034,\n    'SnP_Close': 1179.59,\n    'SnP(t-1))': 1177.8,\n    'SnP(t-5)': 1186.57,\n    'DJIA_Close': 10215.22,\n    'DJIA(t-1))': 10281.1,\n    'DJIA(t-5)': 10287.34,\n\n}\n```\n\n```{python}\n# Create a DataFrame with a single row representing the custom input\ncustom_input_df = pd.DataFrame([custom_input_values])\n\n# Check if column names match\nif set(custom_input_df.columns) == set(feature_names):\n    print(\"Column names match. Continuing with predictions.\")\n\n    # If you used standardization during training, scale the custom input\n    custom_input_scaled = scaler.transform(custom_input_df)\n\n    # Make predictions using the model\n    custom_predictions = model.predict(custom_input_scaled)\n\n    # Optional: Inverse transform if you scaled your target variable during training\n    # custom_predictions_original_scale = scaler.inverse_transform(custom_predictions)\n\n    print(\"Predicted Close Price:\", custom_predictions)\nelse:\n    print(\"Column names do not match. Please check and update the list.\")\nif set(custom_input_df.columns) != set(feature_names):\n    print(set(custom_input_df.columns))\n    print(set(feature_names))\n```\n\nFrom the above result, it is clear that our model can predict closing price of APPL stock on 21 October 2005!\n\n>**Comparing the actual and predicted values on the test dataset**\n\nNow let's compare actual stock price predicted price by the model using the test dataset. \n\n```{python}\n# Predictions on the test set\nY_test_pred = model.predict(X_test)\n\n# Create a DataFrame with actual and predicted values\ndf_pred = pd.DataFrame({'Actual': Y_test.values, 'Predicted': Y_test_pred.flatten()}, index=Y_test.index)\n\n# Reset the index and convert 'Date' to datetime\ndf_pred.reset_index(inplace=True)\ndf_pred['Date'] = pd.to_datetime(df_pred['Date'], format='%Y-%m-%d')\n\n# Display the DataFrame\nprint(df_pred)\n```\n>**Visualization of the predictions**\n\n\nNow the predicted values are plotted along with the actual values to assess how close the prediction is. A scatter plot is used for this purpose. Train, validation and test set is used for this scatter plot to check the model bias in prediction.\n\n```{python}\n\n# Function to create scatter plot for subplots\ndef scatter_plot_subplot(ax, actual, predicted, title, color='blue'):\n    ax.scatter(actual, predicted, color=color, label='Predicted')\n    ax.plot(actual, actual, color='red', linestyle='--', label='Actual')  # Line for actual values\n    ax.set_title(title)\n    ax.set_xlabel('Actual Values')\n    ax.set_ylabel('Predicted Values')\n    ax.legend()\n```\n\n```{python}\n# Predictions on the training, validation, and test sets\nY_train_pred = model.predict(X_train)\nY_val_pred = model.predict(X_val)\nY_test_pred = model.predict(X_test)\n```\n\n```{python}\n#| label: fig-prediction\n#| fig-cap: \"Skill of the model in stock price prediction.(a) Performance in training data, (b) Performance in validation data and (c) Performance in the test data.\"\n# Create a figure with subplots\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Create scatter plots for training, validation, and test sets\nscatter_plot_subplot(axes[0], Y_train, Y_train_pred, '(a)Training Set - Actual vs Predicted', color='green')\nscatter_plot_subplot(axes[1], Y_val, Y_val_pred, '(b)Validation Set - Actual vs Predicted', color='orange')\nscatter_plot_subplot(axes[2], Y_test, Y_test_pred, '(c)Test Set - Actual vs Predicted', color='purple')\n\n# Adjust layout\nplt.tight_layout()\nplt.show()\n```\n\n### Task 2: Classification \n\n>**Problem statement**\n\nPredicting the age of abalone from physical measurements.  The age of abalone is determined by cutting the shell through the cone, staining it, and counting the number of rings through a microscope -- a boring and time-consuming task.  Other measurements, which are easier to obtain, are used to predict the age.  Further information, such as weather patterns and location (hence food availability) may be required to solve the problem.^[source: <https://archive.ics.uci.edu/dataset/1/abalone>]\n\nThe goal of the task is to develop a model that can predict the age of an abalone based purely on the other physical measurements. This would allow researchers to estimate the abaloneâ€™s age without having to cut its shell and count the rings.Details of the dataset is shown in the following table.\n\n| Variable Name     | Role     | Type         | Description                    | Units       | Missing Values |\n|-------------------|----------|--------------|--------------------------------|-------------|----------------|\n| Sex               | Feature  | Categorical  | M, F, and I (infant)           | -           | no             |\n| Length            | Feature  | Continuous   | Longest shell measurement      | mm          | no             |\n| Diameter          | Feature  | Continuous   | Perpendicular to length        | mm          | no             |\n| Height            | Feature  | Continuous   | With meat in shell             | mm          | no             |\n| Whole_weight      | Feature  | Continuous   | Whole abalone                  | grams       | no             |\n| Shucked_weight    | Feature  | Continuous   | Weight of meat                 | grams       | no             |\n| Viscera_weight    | Feature  | Continuous   | Gut weight (after bleeding)    | grams       | no             |\n| Shell_weight      | Feature  | Continuous   | After being dried              | grams       | no             |\n| Rings             | Target   | Integer      | +1.5 gives the age in years    | -           | no             |\n\n\n![Abalone's picture](https://upload.wikimedia.org/wikipedia/commons/3/33/LivingAbalone.JPG)\n\n\n>**Base line analysis**\n\nIn this stage, the data will be loaded from the UCI repository through the url and a primary investigation is conducted for assessing the data quality.\n\n```{python}\n# Loading the dataset\nurl = 'http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data'\ncolumns = ['Sex', 'Length', 'Diameter', 'Height', 'Whole weight', 'Shucked weight', 'Viscera weight', 'Shell weight', 'Rings']\ndf = pd.read_csv(url, header=None, names=columns)\n```\n```{python}\ndf.shape # display the dimension of the data matrix\n```\n>**Summary of dataset**\n\nThe Abalone dataset contains 4175 samples with 8 input features and one target varable. A descriptive summary of the dataset is created for the baseline observation.\n\n```{python}\n# display descriptive summary\ndf.describe()\n```\n\nIn this dataset, the target variable is a class variable containing 29 classes ranging from 1 to 29. Distribution of these classes is shown in @fig-abaloneclass.\n\n```{python}\n#| label: fig-abaloneclass\n#| fig-cap: \"Distribution of classes in the target variable.\"\nsns.countplot(x='Rings', data=df)\nplt.title('Distributed Classes', fontsize=14)\nplt.show()\n```\nFrom the @fig-abaloneclass, it is clear that in the dataset there is a terrible class imbalance. A clear picture of class wise distribution of data is shown in the following table.\n\n```{python}\n# Count each category in the \"Rings\" column and sort in descending order\ncategory_counts = df['Rings'].value_counts()\n\n# Convert the counts to a markdown table\nmarkdown_table = category_counts.reset_index().rename(columns={'index': 'Rings'})\nprint(markdown_table)\n```\n\n**Observation:** Since there is a terrible class imbalance in the dataset, a suitable target variable must be created to design a skillful model in this context.  \n\n>**Check for Missing values**\n\nAs part of the data cleaning, a missing value check is done as follows.\n\n```{python}\n# checking for missing values\nnp.sum(df.isnull(),axis=0)\n```\n\n```{python}\ndf[df['Height'] == 0]  #need to drop these rows.\n```\n>**Observations:** It is clear that there are no missing values, but at least one sample contain wrong height information (height=0!). So such samples will be removed as the part of data cleaning.\n\nSample No. 1257 and 3996 contains wrong infromation regarding the height. So remove these samples first.\n\n```{python}\ndf.drop(index=[1257,3996], inplace = True)\ndf.shape\n```\n\n>**Creating a More Appropriate Dependent Variable**\n\nBy transforming Rings to Age, the data becomes directly interpretable in terms of a universally understood metric: the age of the abalone.\n\n```{python}\ndf['Age'] = df['Rings']+1.5 #AS per the problem statement\ndf.drop('Rings', axis = 1, inplace = True)\ndf.head()\n```\n\n>**Explortory Data Analysis**\n\nExploratory Data Analysis (EDA) is a crucial initial step in the data analysis process. It involves summarizing, visualizing, and interpreting data to uncover patterns, relationships, and insights. By exploring the data, EDA helps in identifying errors, understanding the structure of the dataset, and formulating hypotheses for further analysis.\n\nEDA typically involves descriptive statistics, visualizations, and techniques to identify trends, outliers, and potential relationships between variables.\n\nDistribution of Abalone over the variable Sex is shown in @fig-count.\n\n```{python}\n#| label: fig-count\n#| fig-cap: \"Distribution of Abalone over Sex.\"\nsns.countplot(x='Sex', data=df)\n#plt.title('Distributed Classes', fontsize=14)\nplt.show()\n```\n\nFrom @fig-count, it is clear that there are almost same number of samples over various categories in the variable Sex.\n\n@fig-box demonstrate how the age of Abalone varying over the Sex. \n\n```{python}\n#| label: fig-box\n#| fig-cap: \"Distribution of Age over Sex.\"\n#categorical features\nimport seaborn as sns\nf, ax = plt.subplots(figsize=(8, 6))\nfig = sns.boxenplot(x='Sex', y=\"Age\", data=df)\nfig.axis(ymin=0, ymax=35);\n```\n\nIt is found that there is no significant difference in the  distribution of statistical parameters , but shows a relatively lower value for the infant (I) category. Since the dataset is based on real-life measurements of abalones and the outliers are few, they could represent natural occurrences. Also from the boxplot, it is clear that gender has no significant impact on age. So we can drop this feature without affecting the model performance.\n\n```{python}\n#dropping the variable Sex\ndf.drop('Sex', axis=1, inplace = True)\n```\n\n>**Understanding the Distribution of the Numerical Features**\nNow let's look into the disribution of numerical features. Following Histogram illustrate the distribution of the numerical features.\n\n```{python}\n#| label: fig-hist\n#| fig-cap: \"Distribution ofnumerical features.\"\ndf.hist(figsize = (20,10), layout = (3,3))\n```\n\nFrom @fig-hist, it is observed that the numerical features are highly skewed and so skewness should be found and apply some normalization. Skewness of these numerical features can be found as follows.\n```{python}\n# finding the measure of skewness for numerical features\ntemp = pd.concat([df['Length'], df['Diameter'],df['Height'],df['Whole weight'],df['Shucked weight'],df['Viscera weight'],df['Shell weight']], axis=1)\ntemp.skew().sort_values(ascending = False)\n```\n\nFrom the skewness measures, it is found that the feature Height is highly positively skewed. So it should be normalized using some suitable transformation. Since all the height measures are positive, square root transformation is a better choice. Further we are building a predictive model based on measurable, non-lethal features, the subcomponent weights may be omitted. A final discision will be taken based on correlation analysis.\n\n>**Correlation Analysis**\n\nCorrelation measures the strength and direction of the linear relationship between independent variables (features). A correlation matrix is a common tool for examining relationships between multiple variables.\n\n```{python}\n#| label: fig-cor\n#| fig-cap: \"Correlation matrix of numerical features\"\ncorr = temp.corr()\nplt.figure(figsize = (8,8))\nax = sns.heatmap(corr, vmin = -1, center = 0, annot = True, cmap = 'mako')\n```\n\n@fig-cor shows the correlation matrix of the numerical features in the dataset. As expected, the subcomponents of weight of abalone shows very high correlation with the feature Whole weight, we can drop the subcomponents whithout loosing feature information. Also high coorelation found between the features, Length & Diameter. So let's find those features which shows similar pattern and to be excluded.\n\n```{python}\nupper_tri = corr.where(np.triu(np.ones(corr.shape),k=1).astype(bool))\ncolumns_to_drop = [column for column in upper_tri.columns if any(upper_tri[column] > 0.95)] #highly correlated variables to be removed.\nprint(\"Columns to drop:\\n\", columns_to_drop)\n```\n\n>**Selection of skillful features**\n\nFrom the correlation analysis, Diameter, Shuckle weight, Viscera weight and Shell weights are redundant features. So they are dropped and further the feature Height will be normalized with square root transformation.\n\n```{python}\ndf.drop(columns_to_drop, axis=1, inplace = True)\n# apply square root trasnformation\ndf['Height'] = np.sqrt(df['Height'])\n```\n```{python}\n# rechecking skewness\ndf.skew().sort_values(ascending = False)\n```\n\nNow all the independent variables are near to zero skewness. Following histogram verify this observation.\n\n```{python}\ndf.hist(figsize = (20,10), layout = (2,4), bins = 30)\n```\n\n>**Creation of a new categorical variables using the variable `Age`**\n\nBased on the age distribution of the Abalone in the given datset, a new categroical variable is created as follows:\n$$\n\\text{Age Group}=\\begin{cases}1&;\\quad 2.5\\leq \\text{Age}<9.5\\\\ 2&;\\quad 9.5\\leq \\text{Age}<12.5\\\\3&; \\quad 12.5\\leq \\text{Age}\\leq 30.5\\end{cases}\n$$\n\nNow the structure of the updated dataset will be as follows.\n\n```{python}\ndf['Age_Group'] = pd.cut(x=df['Age'], bins=[2.5,9.5,12.5,30.5],\n                     labels=['1', '2', '3'])\ndf.head()\n```\nDistribution of samples over the newly created categorical variable is shown in @fig-new.\n\n```{python}\n#| label: fig-new\n#| fig-cap: \"Sample distribution over Age_Group.\"\nsns.countplot(x='Age_Group', data=df)\n#plt.title('Distributed Classes')\nplt.show()\n```\n\n>**MLP models for classification**\n\nNow the final data for MLP model can be created as follows. \n\n```{python}\n# creating dataset for classification\n#Length\tHeight\tWhole weight\ndf_c = pd.concat([df['Length'], df['Height'],df['Height'],df['Whole weight'],df['Age_Group']], axis=1)\n# dataset for regression\n\ndf_r = pd.concat([df['Length'], df['Height'],df['Height'],df['Whole weight'],df['Age']], axis=1)\n```\n```{python}\n# prepare input and target from the engineered dataset\nX=df_c.drop('Age_Group', axis = 1)\n#X = df.drop('Age_Group', axis = 1)\ny = df['Age_Group']\n```\n\n>**Bulding MLP model**\n\nIn this section we will build an MLP model with two hidden layers for the classification job. `Python` code for this task is given below.\n\n\n```{python}\n# loading libraries: classification mlp model for the abalone dataset\nfrom numpy import unique\nfrom numpy import argmax\nfrom pandas import read_csv\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\n```\n```{python}\nX, y = X.astype('float'), y.astype('float')\nn_features = X.shape[1]\n# encode strings to integer\ny = LabelEncoder().fit_transform(y)\nn_class = len(unique(y))\n# split data into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=1)\n# define the keras model\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=n_features, activation='relu', kernel_initializer='he_normal'))\nmodel.add(Dense(10, activation='relu', kernel_initializer='he_normal'))\nmodel.add(Dense(n_class, activation='softmax'))\n# compile the keras model\nmodel.compile(loss='sparse_categorical_crossentropy', optimizer='adam',metrics=['accuracy'])\n# fit the keras model on the dataset\nhistory=model.fit(X_train, y_train, epochs=150, batch_size=32,validation_split=0.2, verbose=False)\n```\n\nModel loss and accuracy during the training and the validation is shown in @fig-Abal.\n\n```{python}\n#| label: fig-Abal\n#| fig-cap: \"Model loss and accuracy during training and validation.\"\n# Plot accuracy and loss from history\nplt.figure(figsize=(8, 5))\n\n# Accuracy plot\nplt.subplot(1, 2, 1)\nplt.plot(history.history['accuracy'], label='Train Accuracy')\nplt.plot(history.history['val_accuracy'], label='Validation Accuracy')\nplt.title('Model Accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Accuracy')\nplt.legend()\n\n# Loss plot\nplt.subplot(1, 2, 2)\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.title('Model Loss')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```\n\n>**Performance Evaluation**\n\nSkill of the MLP classification model that we built is evaluated using the measures- confusion matrix, accuracy, precision, recall, f1 score. Class-wise accuracy will be assessed using the classification report. All these measures are evaluated using the following `Python` code.\n\n```{python}\nfrom sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score,classification_report\nyhat = model.predict(X_test)\n# Calculate confusion matrix\nyhat_class = np.argmax(yhat, axis=1)  # Predicted classes\ncm = confusion_matrix(y_test, yhat_class)\n# Calculate classification metrics\naccuracy = accuracy_score(y_test, yhat_class)\nprecision = precision_score(y_test, yhat_class, average='weighted')  # Weighted for multiclass\nrecall = recall_score(y_test, yhat_class, average='weighted')\nf1 = f1_score(y_test, yhat_class, average='weighted')\n\n# Display metrics\nprint(\"Confusion Matrix:\")\nprint(cm)\nprint(f\"Accuracy: {accuracy:.3f}\")\nprint(f\"Precision: {precision:.3f}\")\nprint(f\"Recall: {recall:.3f}\")\nprint(f\"F1 Score: {f1:.3f}\")\nprint(classification_report(y_test, yhat_class))\n```\n\n>**Key Metrics**:\n\n- **Accuracy**: 0.622  \n  The model correctly classified 62.2% of the total samples. This indicates room for improvement in overall performance.\n\n- **Precision**: 0.610  \n  Precision reflects the proportion of true positive predictions among all positive predictions. A precision of 0.610 suggests a moderate rate of correct positive predictions.\n\n- **Recall**: 0.622  \n  Recall measures the proportion of true positives that were correctly identified. A recall of 0.622 shows the model detects positive samples moderately well.\n\n- **F1 Score**: 0.587  \n  The F1 Score, balancing precision and recall, indicates the model struggles to maintain consistency across all metrics.\n\n>*Class-wise Metrics*:\n\n| Class | Precision | Recall | F1-Score | Support |\n|-------|-----------|--------|----------|---------|\n| **0** | 0.68      | 0.78   | 0.72     | 451     |\n| **1** | 0.59      | 0.74   | 0.66     | 616     |\n| **2** | 0.54      | 0.16   | 0.24     | 311     |\n\n\n- **Class 0**: Performs relatively well with good precision and recall.\n- **Class 1**: Moderate performance but better recall indicates more correct detections for this class.\n- **Class 2**: Poor performance with low recall (16%), indicating the model struggles to detect this class.\n\n>*Overall Metrics*:\n\n| Metric         | Value |\n|-----------------|-------|\n| **Accuracy**    | 0.622 |\n| **Macro Avg**   | 0.610 |\n| **Weighted Avg**| 0.610 |\n\n- **Macro Average**: Unweighted average across classes, showing a slightly lower overall performance.\n- **Weighted Average**: Reflects class imbalance, weighting metrics by the number of samples in each class.\n\n>**Findings**:\n\n1. *Class Imbalance*: Class 2 shows significantly lower recall and F1-score, indicating difficulty in detecting samples from this class.\n2. *Misclassifications*:\n   - Many Class 2 samples are misclassified as Class 1 (223 instances).\n   - Class 0 performs better but still has notable misclassifications into Class 1.\n\n>**Conclusion**:The model performs moderately well overall but struggles with:\n\n- Detecting Class 2 effectively.\n- Managing misclassifications between Class 1 and Class 2.\n\nImproving the dataset balance, refining the model, or employing techniques like class-specific weighting or advanced algorithms could enhance the performance.\n\n----\n\n>**Hyperparameter Tuning for MLP Classification**\n\nIn this section, we will perform hyperparameter tuning on our Multi-Layer Perceptron (MLP) model for classification tasks. The goal is to optimize the model's performance by systematically varying key hyperparameters, including the optimizer type, the number of neurons in hidden layers, the number of hidden layers, and the learning rate used in the optimization algorithm. By exploring different combinations of these hyperparameters, we aim to identify the configuration that yields the best classification accuracy and generalization capability on our dataset.\n\n>*Using different optimizers during minimization of the MSE loss function*\n\n In the initial stage, various optimizers were applied to the same network architecture. The performance metrics for the model with different optimizers are presented below.\n \n\n| Sl.No | Optimizer | Hidden Layers (L1, L2) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|-----------|------------------------|----------|-----------|--------|----------|------------------|\n| 1     | Adam      | 20, 10                 | 0.62     | 0.61      | 0.62   | 0.554    | Relatively Stable|\n| 2     | SGD       | 20, 10                 | 0.61     | 0.60      | 0.61   | 0.570    | Less Stable      |\n| 3     | Rmsprop   | 20, 10                 | 0.61     | 0.617     | 0.616  | 0.573    | Unstable         |\n| 4     | Adadelta  | 20, 10                 | 0.44     | 0.216     | 0.442  | 0.29     | Highly Unstable  |\n| 5     | Adagrad   | 20, 10                 | 0.61     | 0.62      | 0.61   | 0.55     | Unstable         |\n\nFrom the performance metrics, the MLP model with `Adam` optimizer is found to a better performer. For the next stage we fix `Adam` as the optimizer.\n\n>*Changing number of neurons in hidden layers*\n\nIn the next stage, we will vary the number of neurons in the hidden layers while keeping other hyperparameters constant. The performance metrics for the model with different configurations of neurons in the hidden layers will be analyzed to determine the optimal structure for our classification task.\n\n| Sl.No | Hidden Layers (L1, L2) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|------------------------|----------|-----------|--------|----------|------------------|\n| 1     | 30, 10                 | 0.60     | 0.605     | 0.69   | 0.558    | Less Stable      |\n| 2     | 15, 10                 | 0.61     | 0.644     | 0.644  | 0.605    | Less Stable      |\n| 3     | 20, 20                 | 0.621    | 0.621     | 0.614  | 0.605    | Relatively stable|\n| 4     | 20, 30                 | 0.61     | 0.590     | 0.610  | 0.599    | Highly Unstable  |\n\nFrom the performance matric, it is clear that MLP classifier with `Adam` optimizer and hidden layer size (20,20) is relatively a better one in the classification task. In the next stage let's fix the optimizer but add one more hidden layer.\n\n>*Adding More Hidden Layers*\n\nIn this stage of hyperparameter tuning, we will explore the impact of adding an additional hidden layer to our deep neural network (DNN) architecture. The objective is to determine how the inclusion of an extra hidden layer affects the model's performance metrics. By systematically varying the number of hidden layers, we aim to identify the optimal network depth that enhances the model's ability to learn complex patterns in the data while maintaining stability and generalization capability. The results of this experiment will provide insights into the trade-offs between model complexity and performance.\n\n| Sl.No | Hidden Layers (L1, L2,L3) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|---------------------------|----------|-----------|--------|----------|------------------|\n| 1     | 20, 20 ,10                | 0.623    | 0.611     | 0.623  | 0.609    | More Stable      |\n| 2     | 30, 20 ,10                | 0.616    | 0.611     | 0.611  | 0.612    | Less Stable      |\n| 3     | 20, 20 ,20                | 0.621    | 0.621     | 0.614  | 0.605    | Less stable      |\n| 4     | 20, 30 ,20                | 0.618    | 0.607     | 0.618  | 0.595    | Highly Unstable  |\n\nFrom, the table it is clear that MLP model with `Adam` optimizer, (20,20,10) hidden layer pattern is a relatively better stable classifier in this context.\n\n>*Fine Turning the Larning Rate*\n\nThe default learning rate for the `Adam` optimizer is set to 0.001. In this section, we will experiment with different learning rates to evaluate the performance metrics of the model. Specifically, we will test the model with learning rates of $\\eta = 0.001$, $\\eta = 0.01$, and $\\eta = 0.1$. Our findings indicate that increasing the learning rate beyond these values results in greater instability, as evidenced by higher variance across different iterations.\n\n| Sl.No | Layers (L1, L2, L3)  | Learning Rate($\\eta$) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|----------------------|-----------------------|----------|-----------|--------|----------|------------------|\n| 1     | 20, 20, 10           | 0.001                 |0.620     | 0.618     | 0.620  |  0.607   |    More Stable   |\n| 2     | 20, 20, 10           | 0.010                 |0.623     | 0.615     | 0.623  |  0.616   |         Stable   |\n| 3     | 20, 20, 10           | 0.100                 |0.609     | 0.488     | 0.609  |  0.534   |    Less Stable   |\n\n\n>*Interpretation and Conclusion*\n\nIn the context of this study, feature preprocessing is crucial to ensure both the ethical collection of data and the accuracy of the model. According to information from the UCI data repository, many features were derived from the killing of Abalones. To promote sustainability and avoid further harm to the Abalone population, our aim is to select only linearly independent features that can produce maximum accuracy without necessitating additional data collection through harmful means.\n\nFurthermore, a careful analysis of the data reveals no significant relationship between the feature values and the age of abalones. Therefore, instead of designing a model with age or the number of rings as the target variable, we categorize Abalones into three classes: infant, young, and adult (represented as Class 1, Class 2, and Class 3, respectively). This approach  simplifies the classification task, making it more practical and ethically responsible. By focusing on these categories, we aim to develop a robust model that can accurately classify the samples while adhering to ethical standards and promoting the conservation of the species.\n\nThe results indicate that the MLP classifier's performance on the Abalone dataset varies with different learning rates. With a learning rate of 0.001, the model achieves an accuracy of 0.620, precision of 0.618, recall of 0.620, and an F1-score of 0.607, and is considered more stable. Increasing the learning rate to 0.010 slightly improves the accuracy to 0.623, with a precision of 0.615, recall of 0.623, and an F1-score of 0.616, maintaining stability. However, further increasing the learning rate to 0.100 results in a decrease in performance, with an accuracy of 0.609, precision of 0.488, recall of 0.609, and an F1-score of 0.534, indicating less stability.\n\n\n\nIn conclusion, the MLP classifier with the Adam optimizer performs best (on an average) with a learning rate of 0.010, achieving the highest accuracy and maintaining stability. The results suggest that while the model is relatively stable with lower learning rates, higher learning rates lead to decreased performance and stability. Therefore, careful tuning of the learning rate is crucial for optimizing the performance of the MLP classifier on the Abalone dataset.\n\n","srcMarkdownNoYaml":"\n\n\n# Evaluation 1\n\n\n```{python}\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings('ignore') # suppress warning\n```\n\n\n##  Design of a DNN from the scrtach.\n\n### Problem statement\nDesign the deep neural network based on the user input. Compute the number of learnable parameters in each layer. The design of the architecture and the number of learnable parameters must be printed. (Comments are required for the understandability of the logic behind the code. Hidden layer computation can be written as function file. Direct function available as built-in library package must not be used). \n\n----\n\n**Solution**\n\n>**Goal**\nThe goal of this problem is to design and implement an Artificial Neural Network (ANN) from scratch using Object-Oriented Programming (OOP) principles. The implementation should allow users to create an instance of the `model`, add `layers` in a manner similar to `Keras`, and finally call a `summary()` method to print the architecture and the number of learnable parameters. The project should also include the implementation of a Dropout layer to help prevent overfitting.\n\n>**Objectives**\n\n\n1. *Design an OOP Architecture:* Develop a clear and flexible OOP architecture for building and managing neural networks. This architecture should include base classes and specific layer classes such as `Dense` and `Dropout`.\n2. *Implement Layer Classes:* Implement the `Dense` and `Dropout layer classes, including methods to compute the number of learnable parameters and perform the forward pass.\n3. *Create a Neural Network Class:* Implement a NeuralNetwork class that allows users to add layers, compute the total number of parameters, perform the forward pass, and print the summary of the model.\n4. *Include Dropout Functionality:* Implement the Dropout layer to randomly set a fraction of input units to 0 during training and scale the remaining units to maintain the expected value.\n4. *Provide User-Friendly Interface:* Ensure that the user can create an instance of the model, add layers in a manner similar to Keras, and call `model.summary()` to print the architecture and the number of learnable parameters.\n\n>**Deliverables**\n\n-  *Source Code:* The complete source code for the ANN implementation, including the Layer, Dense, Dropout, and NeuralNetwork classes.\n- *Demonstration:* A script demonstrating how to create an instance of the model, add layers, and call model.summary() to print the architecture and the number of learnable parameters.\n- *Documentation:* A detailed description of the OOP architecture, explaining the role and functionality of each class and how they work together to achieve the goal of designing an ANN.\n\nThe following source code should include the design and  implementation of the Layer, Dense, Dropout, and NeuralNetwork classes required for an ANN architecture.\n\n*Note:* The Dropout class is implemented the dropout functionality as described by Andrew Ng^[<https://github.com/ashishpatel26/Andrew-NG-Notes/blob/master/andrewng-p-2-improving-deep-learning-network.md#dropout-regularization>].\n\n\n>**Description of the OOP Architecture for Designing an Artificial Neural Network**\n\nThe provided code implements an Artificial Neural Network (ANN) using Object-Oriented Programming (OOP) principles. The architecture is designed to allow users to create an instance of the model, add layers in a manner similar to Keras, and finally call `model.summary()` to print the architecture and the number of learnable parameters. The key components of this architecture are the `Layer`, `Dense`, `Dropout`, and `NeuralNetwork` classes. For this design only the `NumPy` library is used for numerical computations involved in model parameter calculations.\n\n>**OOPs Architecture- Block diagram**\n\n::: {#fig-OOP}\n```{mermaid}\nclassDiagram\n    class Layer {\n        +int params\n        +forward(x, training=True)\n        +compute_params() int\n    }\n\n    class Activation {\n        +string activation\n        +validate_activation()\n        +forward(x, training=True)\n    }\n\n    class Dense {\n        +int input_units\n        +int output_units\n        +array weights\n        +array biases\n        +Activation activation\n        +compute_params() int\n        +forward(x, training=True)\n    }\n\n    class Dropout {\n        +float rate\n        +forward(x, training=True)\n    }\n\n    class NeuralNetwork {\n        +tuple input_shape\n        +list layers\n        +add(layer)\n        +compute_total_params() int\n        +forward(x, training=True)\n        +summary()\n    }\n\n    Layer <|-- Activation\n    Layer <|-- Dense\n    Layer <|-- Dropout\n    NeuralNetwork \"1\" *-- \"many\" Layer\n```\n\nBlock diagram of OOP approach used in the proposed ANN architecture.\n\n:::\n\nA block diagram illustrating the OOP architecture of the proposed ANN model is shown in Figure @fig-OOP.\n\n```{python}\n# importing NumPy instance\nimport numpy as np\n```\n\n>*Layer Class*:\nThe Layer class serves as a base class for all layers in the neural network. It includes methods to compute the number of parameters and perform the forward pass. This class is designed to be inherited by specific layer types such as Dense and Dropout.\n\n*Attributes:*\n\n- `params`: Stores the number of learnable parameters in the layer.\nMethods:\n\n- `compute_params()`: Returns the number of learnable parameters.\n\n- `forward(x, training=True)`: Placeholder method for the forward pass, to be implemented by subclasses.\n\n```{python}\n# defintion of the layer class (super class)\nclass Layer:\n    def __init__(self):\n        self.params = 0\n\n    def forward(self, x, training=True):\n        raise NotImplementedError\n\n    def compute_params(self):\n        return self.params\n```\n\n>*Activation Class:* Implements different activation functions such as `sigmoid`, `relu`, and `softmax`.\n\n*Attributes*:\n- `activation`: The type of activation function to use.\nMethods:\n- `forward(x, training=True)`: Applies the specified activation function to the input.\n\n```{python}\n# defining the Activation class and its methods\nclass Activation(Layer):\n    def __init__(self, activation):\n        super().__init__()\n        self.activation = activation\n        self.validate_activation()\n\n    def validate_activation(self):\n        supported_activations = ['sigmoid', 'relu', 'softmax']\n        if self.activation not in supported_activations:\n            raise ValueError(f\"Unsupported activation function: {self.activation}. Supported activations are: {supported_activations}\")\n\n    def forward(self, x, training=True):\n        if self.activation == 'sigmoid':\n            return 1 / (1 + np.exp(-x))\n        elif self.activation == 'relu':\n            return np.maximum(0, x)\n        elif self.activation == 'softmax':\n            exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n            return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n```\n\n>*Dense Class:*\nThe Dense class inherits from the Layer class and implements a fully connected (dense) layer. It includes the computation of the number of parameters and the forward pass.\n\n*Attributes*:\n\n- `input_units`: Number of input units to the layer.\n- `output_units`: Number of output units from the layer.\n- `weights`: Weight matrix of the layer, initialized with random values.\n- `biases`: Bias vector of the layer, initialized with random values.\n\n*Methods*:\n\n- `compute_params()`: Computes and returns the number of learnable parameters (weights and biases).\n- `forward(x, training=True)`: Implements the forward pass by performing a matrix multiplication of the input with the weights and adding the biases.\n\n```{python}\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, activation=None):\n        super().__init__()\n        self.input_units = input_units\n        self.output_units = output_units\n        self.weights = np.random.randn(output_units, input_units)\n        self.biases = np.random.randn(output_units)\n        self.activation = Activation(activation) if activation else None\n        self.params = self.compute_params()\n\n    def compute_params(self):\n        weight_params = self.input_units * self.output_units\n        bias_params = self.output_units\n        return weight_params + bias_params\n\n    def forward(self, x, training=True):\n        z = np.dot(self.weights, x) + self.biases\n        if self.activation:\n            return self.activation.forward(z, training)\n        return z\n```\n\n>*Dropout Class:*\nThe Dropout class inherits from the Layer class and implements a dropout layer. Dropout is a regularization technique that helps prevent overfitting by randomly setting a fraction of input units to 0 during training.\n\n*Attributes*:\n\n- `rate`: Dropout rate, representing the fraction of input units to be dropped.\n\n*Method*:\n\n- `forward(x, training=True)`: Implements the forward pass. During training, it randomly sets a fraction of input units to 0 and scales the remaining units to maintain the expected value.\n\n```{python}\n# defintion of Dropout class and its methods\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def forward(self, x, training=True):\n        if training:\n            keep_prob = 1 - self.rate\n            mask = np.random.rand(*x.shape) < keep_prob\n            x = np.multiply(x, mask)\n            x = x / keep_prob\n        return x\n```\n\n>*NeuralNetwork Class:*\nThe NeuralNetwork class represents the entire neural network. It allows users to add layers, compute the total number of parameters, perform the forward pass, and print the summary of the model.\n\n*Attributes:*\n\n- `input_shape`: Shape of the input data.\n- `layers`: List of layers in the neural network.\n\n*Methods*:\n\n- `add(layer)`: Adds a layer to the network.\n- `compute_total_params()`: Computes and returns the total number of learnable parameters in the network by summing the parameters of each layer.\n- `forward(x, training=True)`: Performs the forward pass through the network by sequentially passing the input through each layer.\n- `summary()`: Prints the architecture and the number of learnable parameters for each layer, as well as the total number of parameters.\n\n```{python}\n\n# defining the NeuralNetwork class and its methods\n\nclass NeuralNetwork:\n    def __init__(self, input_shape):\n        self.input_shape = input_shape\n        self.layers = []\n\n    def add(self, layer):\n        self.layers.append(layer)\n\n    def compute_total_params(self):\n        total_params = 0\n        for layer in self.layers:\n            total_params += layer.compute_params()\n        return total_params\n\n    def forward(self, x, training=True):\n        for layer in self.layers:\n            x = layer.forward(x, training)\n        return x\n\n    def summary(self):\n        print(\"Neural Network Summary\")\n        for layer in self.layers:\n            if isinstance(layer, Dense):\n                activation = layer.activation.activation if layer.activation else 'None'\n                print(f\"Dense Layer: Units={layer.output_units}, Activation={activation}, Params={layer.compute_params()}\")\n            elif isinstance(layer, Dropout):\n                print(f\"Dropout Layer: Rate={layer.rate}\")\n        print(f\"Total Parameters: {self.compute_total_params()}\")\n```\n\n>**Demonstration**\n\nThe example usage demonstrates how to create an instance of the `NeuralNetwork` class, `add layers` to the `model`, and call `model.summary()` to print the architecture and the number of learnable parameters.\n\n```{python}\n# Example usage\ninput_shape = (784,)  # Example input shape for MNIST dataset (28x28 images flattened)\n\n# Create the model with input layer\nmodel = NeuralNetwork(input_shape)\n# Add first hidden layer with 128 neurons and relu activation to the model\nmodel.add(Dense(input_shape[0], 128, activation='relu'))\n# Add dropout layer with rate 0.5\nmodel.add(Dropout(0.5))\n# Add second hidden layer with 64 neurons and relu activation to the model\nmodel.add(Dense(128, 64, activation='relu'))\n# Add dropout layer with rate 0.5\nmodel.add(Dropout(0.5))\n# Add output layer with 10 neurons and softmax activation for 10 class classification\nmodel.add(Dense(64, 10, activation='softmax'))  # Output layer for 10 classes\n# Print the summary of the model\nmodel.summary()\n```\n\n>**Complete implementation**\n\n```{python}\nimport numpy as np\n\nclass Layer:\n    def __init__(self):\n        self.params = 0\n\n    def forward(self, x, training=True):\n        raise NotImplementedError\n\n    def compute_params(self):\n        return self.params\n\nclass Activation(Layer):\n    def __init__(self, activation):\n        super().__init__()\n        self.activation = activation\n        self.validate_activation()\n\n    def validate_activation(self):\n        supported_activations = ['sigmoid', 'relu', 'softmax']\n        if self.activation not in supported_activations:\n            raise ValueError(f\"Unsupported activation function: {self.activation}. Supported activations are: {supported_activations}\")\n\n    def forward(self, x, training=True):\n        if self.activation == 'sigmoid':\n            return 1 / (1 + np.exp(-x))\n        elif self.activation == 'relu':\n            return np.maximum(0, x)\n        elif self.activation == 'softmax':\n            exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n            return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n\n\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, activation=None):\n        super().__init__()\n        self.input_units = input_units\n        self.output_units = output_units\n        self.weights = np.random.randn(output_units, input_units)\n        self.biases = np.random.randn(output_units)\n        self.activation = Activation(activation) if activation else None\n        self.params = self.compute_params()\n\n    def compute_params(self):\n        weight_params = self.input_units * self.output_units\n        bias_params = self.output_units\n        return weight_params + bias_params\n\n    def forward(self, x, training=True):\n        z = np.dot(self.weights, x) + self.biases\n        if self.activation:\n            return self.activation.forward(z, training)\n        return z\n\nclass Dropout(Layer):\n    def __init__(self, rate):\n        super().__init__()\n        self.rate = rate\n\n    def forward(self, x, training=True):\n        if training:\n            keep_prob = 1 - self.rate\n            mask = np.random.rand(*x.shape) < keep_prob\n            x = np.multiply(x, mask)\n            x = x / keep_prob\n        return x\n\nclass NeuralNetwork:\n    def __init__(self, input_shape):\n        self.input_shape = input_shape\n        self.layers = []\n\n    def add(self, layer):\n        self.layers.append(layer)\n\n    def compute_total_params(self):\n        total_params = 0\n        for layer in self.layers:\n            total_params += layer.compute_params()\n        return total_params\n\n    def forward(self, x, training=True):\n        for layer in self.layers:\n            x = layer.forward(x, training)\n        return x\n\n    def summary(self):\n        print(\"Neural Network Summary\")\n        for layer in self.layers:\n            if isinstance(layer, Dense):\n                activation = layer.activation.activation if layer.activation else 'None'\n                print(f\"Dense Layer: Units={layer.output_units}, Activation={activation}, Params={layer.compute_params()}\")\n            elif isinstance(layer, Dropout):\n                print(f\"Dropout Layer: Rate={layer.rate}\")\n        print(f\"Total Parameters: {self.compute_total_params()}\")\n\n# Example usage\ninput_shape = (784,)  # Example input shape for MNIST dataset (28x28 images flattened)\n\n# Create the model\nmodel = NeuralNetwork(input_shape)\n\n# Add layers to the model\nmodel.add(Dense(input_shape[0], 128, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, 64, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, 64, activation='relu'))\n\nmodel.add(Dense(64, 10, activation='softmax'))  # Output layer for 10 classes\n\n# Print the summary of the model\nmodel.summary()\n```\n\n----\n\n## Popular Activation Functions in Deep Learning\n\n### Problem statement\n\nExplore atleast 3 different activation functions used in the deep learning. Present the mathematical equation (with all variables defined) and plot the same.\n\n**Solution:**\n\n>1. *Sigmoid Activation Function:*\nThe Sigmoid activation function is defined as: $$\\sigma(x) = \\dfrac{1}{1 + e^{-x}}$$\n\n- As  $x \\to -\\infty$, $\\sigma(x) \\to 0$.\n- As $x \\to +\\infty$, $\\sigma(x) \\to 1$.\n- The curve smoothly transitions from 0 to 1, creating an \"S\" shape.\n\n>**Properties**\n\n- *S-shape*: The function's smooth curve has two asymptotes (at 0 and 1), creating the S-like appearance.\n- *Monotonic*: Always increasing.\n- *Differentiable*: Smooth changes without sharp edges.\n- *Derivative*: $\\sigma'(x)=\\sigma(x)\\left(1-\\sigma(x)\\right)$\n\n*Graph:* Graph of the sigmoid function is plotted as shown in @fig-sigmoid:\n\n```{python}\n#| label: fig-sigmoid\n#| fig-cap: \"Graph of sigmoid activation function\"\n\n# importing libraries for numerical computation and plotting\nimport numpy as np\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\nx = np.linspace(-10, 10, 400)\ny = sigmoid(x)\n\nplt.plot(x, y)\nplt.title('$\\sigma(x)=\\dfrac{1}{1+e^{-x}}$')\nplt.xlabel('Input (x)')\nplt.ylabel('Output ($\\sigma(x)$)')\nplt.grid(True)\nplt.show()\n```\n\n>2. *Rectified Linear Units (ReLu)*\n\nThe ReLU activation function is defined as: $$\\text{ReLU}(x) = \\max(0, x)=\\begin{cases}x&;\\quad x\\geq 0\\\\ 0&;\\quad x<0\\end{cases}$$\n\n$\\implies$\n- For $x < 0$, $\\text{ReLU}(x) = 0$.\n- For $x \\geq 0$, $\\text{ReLU}(x) = x$.\n\n*Why \"Rectified\"?*\n\n- The term *\"rectified\"* comes from the fact that the function \"corrects\" or \"rectifies\" the negative inputs by mapping them to 0 while leaving positive inputs unchanged.\n\n*Properties*:\n\n- *Simple*: Computationally efficient due to its straightforward implementation.\n- *Non-linear capability*: Despite its linear segment, it allows for non-linear transformations when combined in networks.\n- *Sparsity*: Outputs zero for all negative inputs, introducing sparsity in neural network activations.\n\n```{python}\n#| label: fig-relu\n#| fig-cap: \"Graph of ReLu activation function\"\ndef relu(x):\n    return np.maximum(0, x)\n\ny = relu(x)\n\nplt.plot(x, y)\nplt.title('ReLU Activation Function')\nplt.xlabel('Input (x)')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>3. *Softmax Activation Function*\n\n$$\n\\sigma(z_i) = \\frac{e^{z_i}}{\\sum\\limits_{j=1}^{n} e^{z_j}} \\quad \\text{for } i = 1, \\dots, n\n$$\n\n- $z_i$ is the $i$-th element of the input vector $z$.\n- $e^{z_i}$ ensures all outputs are positive.\n- The sum of all outputs equals 1, making them suitable as probabilities.\n\n*Properties*:\n\n- *Probabilistic Output*: Transforms raw scores into probabilities, with outputs summing to 1.\n- *Sensitivity*: Exponentiation amplifies the relative differences between inputs.\n- *Differentiability*: Unlike argmax, Softmax is differentiable, making it usable in optimization.\n\n```{python}\n#| label: fig-softmax\n#| fig-cap: \"Graph of softmax activation function\"\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x))\n    return exp_x / np.sum(exp_x)\n\nx = np.linspace(-2, 2, 400)\ny = softmax(x)\n\nplt.plot(x, y)\nplt.title('Softmax Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>4. *Leaky ReLu*\n\nThe name *Leaky ReLU* derives from the function's behavior, which is a variant of the *Rectified Linear Unit (ReLU)* activation function. Unlike ReLU, which sets all negative inputs to $0$, Leaky ReLU introduces a *small, non-zero gradient* ($\\alpha$) for negative inputs.This allows some information to \"leak\" through even when the input is negative.\n\nThe Leaky ReLU function is defined as:\n\n$$\nf(x) =\n\\begin{cases}\nx & \\text{if } x \\geq 0 \\\\\n\\alpha x & \\text{if } x < 0\n\\end{cases}\n$$\n\n- $x$ is the input to the function.\n- $\\alpha$ is a small positive constant, often chosen as 0.01, which defines the \"leakiness.\"\n\n*Properties*:\n\n- *Non-zero Gradient for Negative Inputs*: Solves the *dying ReLU problem*, where neurons become inactive due to zero gradients.\n- *Linear for Positive Values*: Retains simplicity and efficiency of ReLU for non-negative inputs.\n- *Parameter $\\alpha$*: Can be set manually or learned during training.\n\n```{python}\n#| label: fig-leakyrelu\n#| fig-cap: \"Graph of Leaky ReLu activation function\"\ndef leaky_relu(x, alpha=0.01):\n    return np.where(x >= 0, x, alpha * x)\n\nx = np.linspace(-10, 10, 400)\ny = leaky_relu(x)\n\nplt.plot(x, y)\nplt.title('Leaky ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>5. *ELU (Exponential Linear Unit)* Activation Function\n\nThe name *ELU* reflects the combination of its two defining characteristics: *Exponential* behavior for negative inputs and a *Linear Unit* for positive inputs.\n$$\nf(x) =\n\\begin{cases}\nx & \\text{if } x > 0 \\\\\n\\alpha (e^x - 1) & \\text{if } x \\leq 0\n\\end{cases}\n$$\n\n*Properties*:\n\n- *Smooth Transition*: ELU is continuous and differentiable, with a smooth gradient that helps optimization during training.\n- *Non-zero Gradient for Negative Inputs*: Unlike ReLU, which outputs zero for negative inputs, ELU introduces a small gradient for $x \\leq 0$, mitigating the *dying ReLU problem*.\n- *Output Range*: Negative outputs are bounded by $-\\alpha$, introducing a degree of normalization.\n- *Linear Behavior for Positive Inputs*: Ensures fast convergence and efficient representation for positive values.\n\n```{python}\n#| label: fig-elu\n#| fig-cap: \"Graph of Exponential ReLu activation function\"\ndef elu(x, alpha=1.0):\n    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))\n\ny = elu(x)\n\nplt.plot(x, y)\nplt.title('ELU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>6. *$\\tanh(x)$ activation function*\n\nThe name *Tanh* comes from the *Hyperbolic Tangent* function, which is defined mathematically as:\n\n$$\n\\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)} = \\frac{e^x - e^{-x}}{e^x + e^{-x}}\n$$\n\n*Properties*:\n\n-  *Range*: $\\tanh(x)$ maps input values to the range $(-1, 1)$.\n-  *Zero-centered Output*: Unlike the sigmoid function, $\\tanh(x)$ outputs values symmetrically around zero, making it more effective for training neural networks as it reduces bias in gradient updates.\n-  *Non-linearity*: Provides a smooth and non-linear transformation of the input.\n-  *Gradient*: The derivative of $\\tanh(x)$ is:\n   $$\n   \\frac{d}{dx}\\tanh(x) = 1 - \\tanh^2(x)\n   $$\n\n```{python}\n#| label: fig-tanh\n#| fig-cap: \"Graph of Exponential tanh activation function\"\ndef tanh(x):\n    return np.tanh(x)\n\ny = tanh(x)\n\nplt.plot(x, y)\nplt.title('Tanh Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\nplt.show()\n```\n\n>*Comparison: $\\tanh(x)$ vs. Sigmoid*\n\n| Feature                     | $\\tanh(x)$                                    | $Sigmoid$                                     |\n|-----------------------------|------------------------------------------------|---------------------------------------------|\n| **Range**                   | $(-1, 1)$                                   | $(0, 1)$                                  |\n| **Zero-centered Output**    | Yes                                           | No                                          |\n| **Gradient**                | Steeper than sigmoid, improving convergence    | Can saturate for extreme values ( $\\pm x$ ) |\n| **Formula**                 | $\\frac{e^x - e^{-x}}{e^x + e^{-x}}$          | $\\frac{1}{1 + e^{-x}}$                    |\n| **Bias in Updates**         | No (zero-centered output)                      | Yes (output always positive)                |\n| **Usage**                   | Preferred in deep networks for faster training | Often used in output layers for probabilities|\n\n\nA visual comparison of all the activation functions together is shown in @fig-comp.\n\n```{python}\n#| label: fig-comp\n#| fig-cap: \"Visual comparionn of popular activation functions\"\n# Sigmoid Activation Function\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\n# ReLU Activation Function\ndef relu(x):\n    return np.maximum(0, x)\n\n# Softmax Activation Function\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x))\n    return exp_x / np.sum(exp_x)\n\n# Leaky ReLU Activation Function\ndef leaky_relu(x, alpha=0.01):\n    return np.where(x >= 0, x, alpha * x)\n\n# ELU Activation Function\ndef elu(x, alpha=1.0):\n    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))\n\n# Tanh Activation Function\ndef tanh(x):\n    return np.tanh(x)\n\n# Plotting the activation functions\nx = np.linspace(-10, 10, 400)\n\nplt.figure(figsize=(12, 8))\n\n# Sigmoid\nplt.subplot(2, 3, 1)\nplt.plot(x, sigmoid(x))\nplt.title('Sigmoid Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# ReLU\nplt.subplot(2, 3, 2)\nplt.plot(x, relu(x))\nplt.title('ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Softmax\nplt.subplot(2, 3, 3)\nplt.plot(x, softmax(x))\nplt.title('Softmax Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Leaky ReLU\nplt.subplot(2, 3, 4)\nplt.plot(x, leaky_relu(x))\nplt.title('Leaky ReLU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# ELU\nplt.subplot(2, 3, 5)\nplt.plot(x, elu(x))\nplt.title('ELU Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\n# Tanh\nplt.subplot(2, 3, 6)\nplt.plot(x, tanh(x))\nplt.title('Tanh Activation Function')\nplt.xlabel('Input')\nplt.ylabel('Output')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n\n## Comparison of Activation Functions\n\n| Activation Function | Properties | Strengths | Weaknesses |\n|---------------------|------------|-----------|------------|\n| **Sigmoid**         | S-shaped curve, outputs range (0, 1) | Smooth gradient, outputs can be interpreted as probabilities | Vanishing gradient problem, slow convergence |\n| **Softmax**         | Generalization of sigmoid, outputs sum to 1 | Useful for multi-class classification, outputs probabilities | Computationally expensive, can be sensitive to outliers |\n| **ReLU (Rectified Linear Unit)** | Outputs zero for negative inputs, linear for positive inputs | Computationally efficient, mitigates vanishing gradient problem | Can suffer from \"dying ReLU\" problem where neurons become inactive |\n| **Leaky ReLU**      | Similar to ReLU, but allows a small gradient for negative inputs | Prevents \"dying ReLU\" problem, retains benefits of ReLU | Introduces a small bias in the model |\n| **Exponential ReLU (ELU)** | Similar to ReLU, but smooths the curve for negative inputs | Reduces bias shift, faster learning | Computationally more expensive, can still suffer from vanishing gradient |\n| **Tanh**            | S-shaped curve, outputs range (-1, 1) | Zero-centered outputs, stronger gradients than sigmoid | Vanishing gradient problem, slower convergence compared to ReLU |\n\n\n---- \n\n\n## Solution of real world problems using MLP\n\n\nIdentify a dataset and build your own deep neural network architecture for the following:\n\n1. Regression                                                         \n2. Classification (multi-class).\n\n*Note:* Built-in library packages can be used to implement this question. Plot the loss curves. Print the performance evaluation measures.\n\n**Solution**\n\n\n### Task 1: Regression Model\n\n>**Task 1: Stock market prediction**\n\n>**Problem Statement:**\n\nThe goal of this task is to predict the future Apple stock price (Close price) based on historical stock market data over a four-year period. The data includes various financial indicators and technical analysis features, such as stock opening, closing, and volume, along with moving averages, exponential moving averages (EMA), relative strength index (RSI), force index, and other financial market indicators.\n\nThe dataset contains the following features:\n\n**Stock Data Columns:**\n\n- **Open**, **High**, **Low**, **Close**, **Volume**: Basic stock market data representing the price points and volume for Apple stock.\n  \n**Technical Indicators:**\n\n- **SD20**, **Upper_Band**, **Lower_Band**: Bollinger Bands indicators based on the 20-day standard deviation.\n- **S_Close(t-1)**, **S_Close(t-2)**, **S_Close(t-3)**, **S_Close(t-5)**: Lagged closing prices.\n- **S_Open(t-1)**: Lagged opening price.\n- **MA5**, **MA10**, **MA20**, **MA50**, **MA200**: Moving averages of the closing prices over different time intervals.\n- **EMA10**, **EMA20**, **EMA50**, **EMA100**, **EMA200**: Exponential moving averages for different periods.\n- **MACD**, **MACD_EMA**: Moving Average Convergence Divergence and its exponential moving average.\n- **ATR**: Average True Range, measuring market volatility.\n- **ADX**: Average Directional Index, used to determine the strength of a trend.\n- **CCI**: Commodity Channel Index, used to identify cyclical trends.\n- **ROC**: Rate of Change, measuring the percentage change in price.\n- **RSI**: Relative Strength Index, an oscillator that measures the speed and change of price movements.\n- **William%R**: Williams %R, a momentum indicator.\n- **SO%K**: Stochastic Oscillator %K.\n- **STD5**: Standard deviation over the past 5 days.\n- **ForceIndex1**, **ForceIndex20**: Force index, a volume-based indicator of price movement.\n\n**Market Indices Data:**\n\n- **QQQ_Close**, **QQQ(t-1)**, **QQQ(t-2)**, **QQQ(t-5)**: Historical data for the QQQ index.\n- **SnP_Close**, **SnP(t-1)**, **SnP(t-5)**: Historical data for the S&P 500 index.\n- **DJIA_Close**, **DJIA(t-1)**, **DJIA(t-5)**: Historical data for the DJIA index.\n\n**Time-based Features:**\n\n- **Date_col**: Date of the record.\n- **Day**, **DayofWeek**, **DayofYear**, **Week**: Time-based features of the day and year.\n- **Is_month_end**, **Is_month_start**, **Is_quarter_end**, **Is_quarter_start**, **Is_year_end**, **Is_year_start**, **Is_leap_year**: Categorical features indicating various time period markers.\n\nThe task is to build a model that can forecast the **Apple stock price (Close)** for a given future period based on the historical data and technical indicators. The model should leverage time series data, stock market indicators, and macroeconomic factors to predict stock price movements accurately.\n\n**Objectives:**\n\n1. Preprocess the data to handle missing values, scale features, and engineer any additional features if required.\n2. Develop and train machine learning models to predict the Apple stock price using historical data and technical indicators.\n3. Evaluate model performance using appropriate metrics such as Mean Absolute Error (MAE), Mean Squared Error (MSE), and R-squared ($R^2$).\n4. Provide insights into which features are most influential in predicting the Apple stock price.\n\nThe model will be evaluated on its ability to predict the **`Close_forcast`** column, which represents the future Apple stock closing price.\n\n**Expected Outcome:**\n\nThe output will be a reliable regression model capable of forecasting the Apple stock price with acceptable accuracy based on historical trends and technical analysis features.\n\n----\n\nSolution procedure of this task is explained in detail if following section.\n\n>**Step 1: Loading necessary libraries and dataset**\n\n```{python}\nimport pandas as pd # for dataset handling\nimport numpy as np # for numerical computations\n# libraries for ML preprocessing and model performance evaluation tasks\nfrom sklearn.model_selection import cross_val_score, train_test_split\n#from sklearn.feature_selection import RFECV, SelectFromModel, SelectKBest\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import metrics\n%matplotlib inline\n```\n\nA close look at the structure of the data is shown below.\n\n```{python}\nStock = pd.read_csv('https://raw.githubusercontent.com/sijuswamyresearch/24DS611-DL/refs/heads/main/AAPL.csv',  index_col=0)\ndf_Stock = Stock\ndf_Stock = df_Stock.rename(columns={'Close(t)':'Close'})\ndf_Stock.head()\n```\n\nTotal number of features and sample size can be found using the following `python` code.\n\n```{python}\ndf_Stock.shape\n```\n\nFeatures and target in the data set is shown below.\n\n```{python}\ndf_Stock.columns\n```\n\nUsing the native `pandas` `plot`function, the target variable can be visualized as shown in @fig-datav. In the current study only a multiple linear regression model is designed without considering the time series properties of the data.\n\n```{python}\n#| label: fig-datav\n#| fig-cap: \"Apple stock price from the given data\"\ndf_Stock['Close'].plot(figsize=(10, 7))\nplt.title(\"Stock Price\", fontsize=17)\nplt.ylabel('Price', fontsize=14)\nplt.xlabel('Time', fontsize=14)\nplt.grid(which=\"major\", color='k', linestyle='-.', linewidth=0.5)\nplt.show()\n```\n\nFor the MLP model, we are considering only the numerical features available in the dataset. So the date column is dropped as follows.\n\n```{python}\ndf_Stock = df_Stock.drop(columns='Date_col')\n```\n\nIn this work we are using the `Keras` library with Tensorflow backend as the source for basic DNN design and implementations. As usual the pupular ML library `scikitlearn` and its functions will be used for data preparation, scaling and model evaluation. Required methods for model building, compliling and performance evaluation can be loaded as follows.\n\n```{python}\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom sklearn.metrics import mean_squared_error, r2_score\n```\n\nTwo functions will be used for model design, implementation and evaluation.\n\n```{python}\n# Function to create train, validation, and test sets\ndef create_train_test_set(df_Stock):\n    features = df_Stock.drop(columns=['Close_forcast'], axis=1)\n    target = df_Stock['Close_forcast']\n\n    # Normalizing features\n    scaler = StandardScaler()\n    features_scaled = scaler.fit_transform(features)\n\n    # Splitting the dataset\n    X_train, X_temp, Y_train, Y_temp = train_test_split(features_scaled, target, test_size=0.12, random_state=42)\n    X_val, X_test, Y_val, Y_test = train_test_split(X_temp, Y_temp, test_size=0.5, random_state=42)\n\n    return X_train, X_val, X_test, Y_train, Y_val, Y_test, scaler\n\nX_train, X_val, X_test, Y_train, Y_val, Y_test, scaler = create_train_test_set(df_Stock)\n```\n\n```{python}\n# Define MLP model architecture\ndef create_mlp_model(input_dim):\n    model = Sequential()\n    model.add(Dense(64, input_dim=input_dim, activation='relu'))\n    model.add(Dense(32, activation='relu'))\n    model.add(Dense(16, activation='relu'))\n    model.add(Dense(16, activation='relu'))\n    model.add(Dense(1))\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    return model\n```\n\n```{python}\n# Evaluate the model\ndef evaluate_model(model, X_train, Y_train, X_val, Y_val, X_test, Y_test):\n    Y_train_pred = model.predict(X_train)\n    Y_val_pred = model.predict(X_val)\n    Y_test_pred = model.predict(X_test)\n\n\n    print(\"Training MSE:\", mean_squared_error(Y_train, Y_train_pred))\n    print(\"Validation MSE:\", mean_squared_error(Y_val, Y_val_pred))\n    print(\"Test MSE:\", mean_squared_error(Y_test, Y_test_pred))\n\n    print(\"Training R-squared:\", r2_score(Y_train, Y_train_pred))\n    print(\"Validation R-squared:\", r2_score(Y_val, Y_val_pred))\n    print(\"Test R-squared:\", r2_score(Y_test, Y_test_pred))\n```\n\nNow let's buld the model and train using previously defined functions as follows.\n\n```{python}\n# Create and train the MLP model\nmodel = create_mlp_model(X_train.shape[1])\nhistory = model.fit(X_train, Y_train, validation_data=(X_val, Y_val), epochs=60, batch_size=16, verbose=False)\n```\n\n\nNow let's evaluate the regression model using the `evaluate_model` function as follows.\n\n```{python}\nevaluate_model(model, X_train, Y_train, X_val, Y_val, X_test, Y_test)\n```\nThe model loss during training and validation is plotted using following code.\n\n```{python}\n#| label: fig-lossplot\n#| fig-cap: \"Distribution of loss function during training and validation\"\n# Plot training and validation loss\nplt.plot(history.history['loss'], label='train')\nplt.plot(history.history['val_loss'], label='validation')\nplt.title('Model Loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()\n```\n\n>**Conclusion**\n\nThe MLP regression model demonstrates excellent performance with high R-squared values (Training: 0.9990, Validation: 0.9988, Test: 0.9993) and relatively low MSE values (Training: 6.33, Validation: 6.37, Test: 4.64) across all datasets. The slight increase in validation MSE compared to training MSE suggests minimal overfitting, indicating that the model has learned the underlying patterns in the training data without capturing too much noise. The lower test MSE further confirms that the model generalizes well to unseen data, which is a positive indicator of its robustness.\n\nThe high R-squared values across training, validation, and test datasets suggest that the model has a low bias, effectively capturing the complexity of the data. The minimal difference between training and validation metrics indicates low variance, meaning the model's performance is consistent across different datasets. Overall, the model is neither underfitting nor overfitting, striking a good balance between bias and variance, and is well-suited for making accurate predictions on new data.\n\n>**Analysing the skill of the model**\n\nTo check the prediction quality of the model,we need to predict the stock price for a particular input. For these purpose we need to create an input data that is in the form of a dataframe containing all the input features. This is done in the next code cell.\n\n```{python}\n# Feature names used during training\nfeature_names= [\n    'Open', 'High', 'Low','Close', 'Volume', 'SD20', 'Upper_Band', 'Lower_Band',\n    'S_Close(t-1)', 'S_Close(t-2)', 'S_Close(t-3)', 'S_Close(t-5)', 'S_Open(t-1)',\n    'MA5', 'MA10', 'MA20', 'MA50', 'MA200', 'EMA10', 'EMA20', 'EMA50', 'EMA100', 'EMA200',\n    'MACD', 'MACD_EMA', 'ATR', 'ADX', 'CCI', 'ROC', 'RSI', 'William%R', 'SO%K', 'STD5',\n    'ForceIndex1', 'ForceIndex20', 'Day', 'DayofWeek', 'DayofYear', 'Week',\n    'Is_month_end', 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start',\n    'Is_year_end', 'Is_year_start', 'Is_leap_year', 'Year', 'Month',\n    'QQQ_Close', 'QQQ(t-1)', 'QQQ(t-2)', 'QQQ(t-5)', 'QQQ_MA10', 'QQQ_MA20', 'QQQ_MA50',\n    'SnP_Close', 'SnP(t-1))', 'SnP(t-5)', 'DJIA_Close', 'DJIA(t-1))', 'DJIA(t-5)'\n]\n\n# Provided values for input features as a dictionary.\ncustom_input_values = {\n    'Open': 7.02,\n    'High': 7.03,\n    'Low': 6.83,\n    'Close':6.87,\n    'Volume': 199181500,\n    'SD20': 0.216680094,\n    'Upper_Band': 6.974860188,\n    'Lower_Band': 6.108139812,\n    'S_Close(t-1)': 6.93,\n    'S_Close(t-2)': 6.78,\n    'S_Close(t-3)': 6.45,\n    'S_Close(t-5)': 6.67,\n    'S_Open(t-1)': 6.72,\n    'MA5': 6.726,\n    'MA10': 6.56,\n    'MA20': 6.5415,\n    'MA50': 6.209,\n    'MA200': 5.20315,\n    'EMA10': 6.760108607,\n    'EMA20': 6.760108607,\n    'EMA50': 6.760108607,\n    'EMA100': 6.760108607,\n    'EMA200': 6.760108607,\n    'MACD': 0.153339954,\n    'MACD_EMA': 0.129844817,\n    'ATR': 0.24109363,\n    'ADX': 22.06352634,\n    'CCI': 1333.333333,\n    'ROC': 8.530805687,\n    'RSI': 60.683333,\n    'William%R': -14.28571429,\n    'SO%K': 85.71428571,\n    'STD5': 0.030047679,\n    'ForceIndex1': -11950890,\n    'ForceIndex20': 59754450,\n    'Day': 21,\n    'DayofWeek': 4,\n    'DayofYear': 294,\n    'Week': 42,\n    'Is_month_end': 0,\n\n    'Is_month_start': 0,\n    'Is_quarter_end': 0,\n    'Is_quarter_start': 0,\n    'Is_year_end': 0,\n    'Is_year_start': 0,\n    'Is_leap_year': 0,\n    'Year': 2005,\n    'Month': 10,\n    'QQQ_Close': 33.98,\n    'QQQ(t-1)': 33.77,\n    'QQQ(t-2)': 34.09,\n    'QQQ(t-5)': 33.55,\n    'QQQ_MA10': 33.586,\n    'QQQ_MA20': 33.9365,\n    'QQQ_MA50': 34.2034,\n    'SnP_Close': 1179.59,\n    'SnP(t-1))': 1177.8,\n    'SnP(t-5)': 1186.57,\n    'DJIA_Close': 10215.22,\n    'DJIA(t-1))': 10281.1,\n    'DJIA(t-5)': 10287.34,\n\n}\n```\n\n```{python}\n# Create a DataFrame with a single row representing the custom input\ncustom_input_df = pd.DataFrame([custom_input_values])\n\n# Check if column names match\nif set(custom_input_df.columns) == set(feature_names):\n    print(\"Column names match. Continuing with predictions.\")\n\n    # If you used standardization during training, scale the custom input\n    custom_input_scaled = scaler.transform(custom_input_df)\n\n    # Make predictions using the model\n    custom_predictions = model.predict(custom_input_scaled)\n\n    # Optional: Inverse transform if you scaled your target variable during training\n    # custom_predictions_original_scale = scaler.inverse_transform(custom_predictions)\n\n    print(\"Predicted Close Price:\", custom_predictions)\nelse:\n    print(\"Column names do not match. Please check and update the list.\")\nif set(custom_input_df.columns) != set(feature_names):\n    print(set(custom_input_df.columns))\n    print(set(feature_names))\n```\n\nFrom the above result, it is clear that our model can predict closing price of APPL stock on 21 October 2005!\n\n>**Comparing the actual and predicted values on the test dataset**\n\nNow let's compare actual stock price predicted price by the model using the test dataset. \n\n```{python}\n# Predictions on the test set\nY_test_pred = model.predict(X_test)\n\n# Create a DataFrame with actual and predicted values\ndf_pred = pd.DataFrame({'Actual': Y_test.values, 'Predicted': Y_test_pred.flatten()}, index=Y_test.index)\n\n# Reset the index and convert 'Date' to datetime\ndf_pred.reset_index(inplace=True)\ndf_pred['Date'] = pd.to_datetime(df_pred['Date'], format='%Y-%m-%d')\n\n# Display the DataFrame\nprint(df_pred)\n```\n>**Visualization of the predictions**\n\n\nNow the predicted values are plotted along with the actual values to assess how close the prediction is. A scatter plot is used for this purpose. Train, validation and test set is used for this scatter plot to check the model bias in prediction.\n\n```{python}\n\n# Function to create scatter plot for subplots\ndef scatter_plot_subplot(ax, actual, predicted, title, color='blue'):\n    ax.scatter(actual, predicted, color=color, label='Predicted')\n    ax.plot(actual, actual, color='red', linestyle='--', label='Actual')  # Line for actual values\n    ax.set_title(title)\n    ax.set_xlabel('Actual Values')\n    ax.set_ylabel('Predicted Values')\n    ax.legend()\n```\n\n```{python}\n# Predictions on the training, validation, and test sets\nY_train_pred = model.predict(X_train)\nY_val_pred = model.predict(X_val)\nY_test_pred = model.predict(X_test)\n```\n\n```{python}\n#| label: fig-prediction\n#| fig-cap: \"Skill of the model in stock price prediction.(a) Performance in training data, (b) Performance in validation data and (c) Performance in the test data.\"\n# Create a figure with subplots\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Create scatter plots for training, validation, and test sets\nscatter_plot_subplot(axes[0], Y_train, Y_train_pred, '(a)Training Set - Actual vs Predicted', color='green')\nscatter_plot_subplot(axes[1], Y_val, Y_val_pred, '(b)Validation Set - Actual vs Predicted', color='orange')\nscatter_plot_subplot(axes[2], Y_test, Y_test_pred, '(c)Test Set - Actual vs Predicted', color='purple')\n\n# Adjust layout\nplt.tight_layout()\nplt.show()\n```\n\n### Task 2: Classification \n\n>**Problem statement**\n\nPredicting the age of abalone from physical measurements.  The age of abalone is determined by cutting the shell through the cone, staining it, and counting the number of rings through a microscope -- a boring and time-consuming task.  Other measurements, which are easier to obtain, are used to predict the age.  Further information, such as weather patterns and location (hence food availability) may be required to solve the problem.^[source: <https://archive.ics.uci.edu/dataset/1/abalone>]\n\nThe goal of the task is to develop a model that can predict the age of an abalone based purely on the other physical measurements. This would allow researchers to estimate the abaloneâ€™s age without having to cut its shell and count the rings.Details of the dataset is shown in the following table.\n\n| Variable Name     | Role     | Type         | Description                    | Units       | Missing Values |\n|-------------------|----------|--------------|--------------------------------|-------------|----------------|\n| Sex               | Feature  | Categorical  | M, F, and I (infant)           | -           | no             |\n| Length            | Feature  | Continuous   | Longest shell measurement      | mm          | no             |\n| Diameter          | Feature  | Continuous   | Perpendicular to length        | mm          | no             |\n| Height            | Feature  | Continuous   | With meat in shell             | mm          | no             |\n| Whole_weight      | Feature  | Continuous   | Whole abalone                  | grams       | no             |\n| Shucked_weight    | Feature  | Continuous   | Weight of meat                 | grams       | no             |\n| Viscera_weight    | Feature  | Continuous   | Gut weight (after bleeding)    | grams       | no             |\n| Shell_weight      | Feature  | Continuous   | After being dried              | grams       | no             |\n| Rings             | Target   | Integer      | +1.5 gives the age in years    | -           | no             |\n\n\n![Abalone's picture](https://upload.wikimedia.org/wikipedia/commons/3/33/LivingAbalone.JPG)\n\n\n>**Base line analysis**\n\nIn this stage, the data will be loaded from the UCI repository through the url and a primary investigation is conducted for assessing the data quality.\n\n```{python}\n# Loading the dataset\nurl = 'http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data'\ncolumns = ['Sex', 'Length', 'Diameter', 'Height', 'Whole weight', 'Shucked weight', 'Viscera weight', 'Shell weight', 'Rings']\ndf = pd.read_csv(url, header=None, names=columns)\n```\n```{python}\ndf.shape # display the dimension of the data matrix\n```\n>**Summary of dataset**\n\nThe Abalone dataset contains 4175 samples with 8 input features and one target varable. A descriptive summary of the dataset is created for the baseline observation.\n\n```{python}\n# display descriptive summary\ndf.describe()\n```\n\nIn this dataset, the target variable is a class variable containing 29 classes ranging from 1 to 29. Distribution of these classes is shown in @fig-abaloneclass.\n\n```{python}\n#| label: fig-abaloneclass\n#| fig-cap: \"Distribution of classes in the target variable.\"\nsns.countplot(x='Rings', data=df)\nplt.title('Distributed Classes', fontsize=14)\nplt.show()\n```\nFrom the @fig-abaloneclass, it is clear that in the dataset there is a terrible class imbalance. A clear picture of class wise distribution of data is shown in the following table.\n\n```{python}\n# Count each category in the \"Rings\" column and sort in descending order\ncategory_counts = df['Rings'].value_counts()\n\n# Convert the counts to a markdown table\nmarkdown_table = category_counts.reset_index().rename(columns={'index': 'Rings'})\nprint(markdown_table)\n```\n\n**Observation:** Since there is a terrible class imbalance in the dataset, a suitable target variable must be created to design a skillful model in this context.  \n\n>**Check for Missing values**\n\nAs part of the data cleaning, a missing value check is done as follows.\n\n```{python}\n# checking for missing values\nnp.sum(df.isnull(),axis=0)\n```\n\n```{python}\ndf[df['Height'] == 0]  #need to drop these rows.\n```\n>**Observations:** It is clear that there are no missing values, but at least one sample contain wrong height information (height=0!). So such samples will be removed as the part of data cleaning.\n\nSample No. 1257 and 3996 contains wrong infromation regarding the height. So remove these samples first.\n\n```{python}\ndf.drop(index=[1257,3996], inplace = True)\ndf.shape\n```\n\n>**Creating a More Appropriate Dependent Variable**\n\nBy transforming Rings to Age, the data becomes directly interpretable in terms of a universally understood metric: the age of the abalone.\n\n```{python}\ndf['Age'] = df['Rings']+1.5 #AS per the problem statement\ndf.drop('Rings', axis = 1, inplace = True)\ndf.head()\n```\n\n>**Explortory Data Analysis**\n\nExploratory Data Analysis (EDA) is a crucial initial step in the data analysis process. It involves summarizing, visualizing, and interpreting data to uncover patterns, relationships, and insights. By exploring the data, EDA helps in identifying errors, understanding the structure of the dataset, and formulating hypotheses for further analysis.\n\nEDA typically involves descriptive statistics, visualizations, and techniques to identify trends, outliers, and potential relationships between variables.\n\nDistribution of Abalone over the variable Sex is shown in @fig-count.\n\n```{python}\n#| label: fig-count\n#| fig-cap: \"Distribution of Abalone over Sex.\"\nsns.countplot(x='Sex', data=df)\n#plt.title('Distributed Classes', fontsize=14)\nplt.show()\n```\n\nFrom @fig-count, it is clear that there are almost same number of samples over various categories in the variable Sex.\n\n@fig-box demonstrate how the age of Abalone varying over the Sex. \n\n```{python}\n#| label: fig-box\n#| fig-cap: \"Distribution of Age over Sex.\"\n#categorical features\nimport seaborn as sns\nf, ax = plt.subplots(figsize=(8, 6))\nfig = sns.boxenplot(x='Sex', y=\"Age\", data=df)\nfig.axis(ymin=0, ymax=35);\n```\n\nIt is found that there is no significant difference in the  distribution of statistical parameters , but shows a relatively lower value for the infant (I) category. Since the dataset is based on real-life measurements of abalones and the outliers are few, they could represent natural occurrences. Also from the boxplot, it is clear that gender has no significant impact on age. So we can drop this feature without affecting the model performance.\n\n```{python}\n#dropping the variable Sex\ndf.drop('Sex', axis=1, inplace = True)\n```\n\n>**Understanding the Distribution of the Numerical Features**\nNow let's look into the disribution of numerical features. Following Histogram illustrate the distribution of the numerical features.\n\n```{python}\n#| label: fig-hist\n#| fig-cap: \"Distribution ofnumerical features.\"\ndf.hist(figsize = (20,10), layout = (3,3))\n```\n\nFrom @fig-hist, it is observed that the numerical features are highly skewed and so skewness should be found and apply some normalization. Skewness of these numerical features can be found as follows.\n```{python}\n# finding the measure of skewness for numerical features\ntemp = pd.concat([df['Length'], df['Diameter'],df['Height'],df['Whole weight'],df['Shucked weight'],df['Viscera weight'],df['Shell weight']], axis=1)\ntemp.skew().sort_values(ascending = False)\n```\n\nFrom the skewness measures, it is found that the feature Height is highly positively skewed. So it should be normalized using some suitable transformation. Since all the height measures are positive, square root transformation is a better choice. Further we are building a predictive model based on measurable, non-lethal features, the subcomponent weights may be omitted. A final discision will be taken based on correlation analysis.\n\n>**Correlation Analysis**\n\nCorrelation measures the strength and direction of the linear relationship between independent variables (features). A correlation matrix is a common tool for examining relationships between multiple variables.\n\n```{python}\n#| label: fig-cor\n#| fig-cap: \"Correlation matrix of numerical features\"\ncorr = temp.corr()\nplt.figure(figsize = (8,8))\nax = sns.heatmap(corr, vmin = -1, center = 0, annot = True, cmap = 'mako')\n```\n\n@fig-cor shows the correlation matrix of the numerical features in the dataset. As expected, the subcomponents of weight of abalone shows very high correlation with the feature Whole weight, we can drop the subcomponents whithout loosing feature information. Also high coorelation found between the features, Length & Diameter. So let's find those features which shows similar pattern and to be excluded.\n\n```{python}\nupper_tri = corr.where(np.triu(np.ones(corr.shape),k=1).astype(bool))\ncolumns_to_drop = [column for column in upper_tri.columns if any(upper_tri[column] > 0.95)] #highly correlated variables to be removed.\nprint(\"Columns to drop:\\n\", columns_to_drop)\n```\n\n>**Selection of skillful features**\n\nFrom the correlation analysis, Diameter, Shuckle weight, Viscera weight and Shell weights are redundant features. So they are dropped and further the feature Height will be normalized with square root transformation.\n\n```{python}\ndf.drop(columns_to_drop, axis=1, inplace = True)\n# apply square root trasnformation\ndf['Height'] = np.sqrt(df['Height'])\n```\n```{python}\n# rechecking skewness\ndf.skew().sort_values(ascending = False)\n```\n\nNow all the independent variables are near to zero skewness. Following histogram verify this observation.\n\n```{python}\ndf.hist(figsize = (20,10), layout = (2,4), bins = 30)\n```\n\n>**Creation of a new categorical variables using the variable `Age`**\n\nBased on the age distribution of the Abalone in the given datset, a new categroical variable is created as follows:\n$$\n\\text{Age Group}=\\begin{cases}1&;\\quad 2.5\\leq \\text{Age}<9.5\\\\ 2&;\\quad 9.5\\leq \\text{Age}<12.5\\\\3&; \\quad 12.5\\leq \\text{Age}\\leq 30.5\\end{cases}\n$$\n\nNow the structure of the updated dataset will be as follows.\n\n```{python}\ndf['Age_Group'] = pd.cut(x=df['Age'], bins=[2.5,9.5,12.5,30.5],\n                     labels=['1', '2', '3'])\ndf.head()\n```\nDistribution of samples over the newly created categorical variable is shown in @fig-new.\n\n```{python}\n#| label: fig-new\n#| fig-cap: \"Sample distribution over Age_Group.\"\nsns.countplot(x='Age_Group', data=df)\n#plt.title('Distributed Classes')\nplt.show()\n```\n\n>**MLP models for classification**\n\nNow the final data for MLP model can be created as follows. \n\n```{python}\n# creating dataset for classification\n#Length\tHeight\tWhole weight\ndf_c = pd.concat([df['Length'], df['Height'],df['Height'],df['Whole weight'],df['Age_Group']], axis=1)\n# dataset for regression\n\ndf_r = pd.concat([df['Length'], df['Height'],df['Height'],df['Whole weight'],df['Age']], axis=1)\n```\n```{python}\n# prepare input and target from the engineered dataset\nX=df_c.drop('Age_Group', axis = 1)\n#X = df.drop('Age_Group', axis = 1)\ny = df['Age_Group']\n```\n\n>**Bulding MLP model**\n\nIn this section we will build an MLP model with two hidden layers for the classification job. `Python` code for this task is given below.\n\n\n```{python}\n# loading libraries: classification mlp model for the abalone dataset\nfrom numpy import unique\nfrom numpy import argmax\nfrom pandas import read_csv\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\n```\n```{python}\nX, y = X.astype('float'), y.astype('float')\nn_features = X.shape[1]\n# encode strings to integer\ny = LabelEncoder().fit_transform(y)\nn_class = len(unique(y))\n# split data into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=1)\n# define the keras model\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=n_features, activation='relu', kernel_initializer='he_normal'))\nmodel.add(Dense(10, activation='relu', kernel_initializer='he_normal'))\nmodel.add(Dense(n_class, activation='softmax'))\n# compile the keras model\nmodel.compile(loss='sparse_categorical_crossentropy', optimizer='adam',metrics=['accuracy'])\n# fit the keras model on the dataset\nhistory=model.fit(X_train, y_train, epochs=150, batch_size=32,validation_split=0.2, verbose=False)\n```\n\nModel loss and accuracy during the training and the validation is shown in @fig-Abal.\n\n```{python}\n#| label: fig-Abal\n#| fig-cap: \"Model loss and accuracy during training and validation.\"\n# Plot accuracy and loss from history\nplt.figure(figsize=(8, 5))\n\n# Accuracy plot\nplt.subplot(1, 2, 1)\nplt.plot(history.history['accuracy'], label='Train Accuracy')\nplt.plot(history.history['val_accuracy'], label='Validation Accuracy')\nplt.title('Model Accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Accuracy')\nplt.legend()\n\n# Loss plot\nplt.subplot(1, 2, 2)\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.title('Model Loss')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```\n\n>**Performance Evaluation**\n\nSkill of the MLP classification model that we built is evaluated using the measures- confusion matrix, accuracy, precision, recall, f1 score. Class-wise accuracy will be assessed using the classification report. All these measures are evaluated using the following `Python` code.\n\n```{python}\nfrom sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score,classification_report\nyhat = model.predict(X_test)\n# Calculate confusion matrix\nyhat_class = np.argmax(yhat, axis=1)  # Predicted classes\ncm = confusion_matrix(y_test, yhat_class)\n# Calculate classification metrics\naccuracy = accuracy_score(y_test, yhat_class)\nprecision = precision_score(y_test, yhat_class, average='weighted')  # Weighted for multiclass\nrecall = recall_score(y_test, yhat_class, average='weighted')\nf1 = f1_score(y_test, yhat_class, average='weighted')\n\n# Display metrics\nprint(\"Confusion Matrix:\")\nprint(cm)\nprint(f\"Accuracy: {accuracy:.3f}\")\nprint(f\"Precision: {precision:.3f}\")\nprint(f\"Recall: {recall:.3f}\")\nprint(f\"F1 Score: {f1:.3f}\")\nprint(classification_report(y_test, yhat_class))\n```\n\n>**Key Metrics**:\n\n- **Accuracy**: 0.622  \n  The model correctly classified 62.2% of the total samples. This indicates room for improvement in overall performance.\n\n- **Precision**: 0.610  \n  Precision reflects the proportion of true positive predictions among all positive predictions. A precision of 0.610 suggests a moderate rate of correct positive predictions.\n\n- **Recall**: 0.622  \n  Recall measures the proportion of true positives that were correctly identified. A recall of 0.622 shows the model detects positive samples moderately well.\n\n- **F1 Score**: 0.587  \n  The F1 Score, balancing precision and recall, indicates the model struggles to maintain consistency across all metrics.\n\n>*Class-wise Metrics*:\n\n| Class | Precision | Recall | F1-Score | Support |\n|-------|-----------|--------|----------|---------|\n| **0** | 0.68      | 0.78   | 0.72     | 451     |\n| **1** | 0.59      | 0.74   | 0.66     | 616     |\n| **2** | 0.54      | 0.16   | 0.24     | 311     |\n\n\n- **Class 0**: Performs relatively well with good precision and recall.\n- **Class 1**: Moderate performance but better recall indicates more correct detections for this class.\n- **Class 2**: Poor performance with low recall (16%), indicating the model struggles to detect this class.\n\n>*Overall Metrics*:\n\n| Metric         | Value |\n|-----------------|-------|\n| **Accuracy**    | 0.622 |\n| **Macro Avg**   | 0.610 |\n| **Weighted Avg**| 0.610 |\n\n- **Macro Average**: Unweighted average across classes, showing a slightly lower overall performance.\n- **Weighted Average**: Reflects class imbalance, weighting metrics by the number of samples in each class.\n\n>**Findings**:\n\n1. *Class Imbalance*: Class 2 shows significantly lower recall and F1-score, indicating difficulty in detecting samples from this class.\n2. *Misclassifications*:\n   - Many Class 2 samples are misclassified as Class 1 (223 instances).\n   - Class 0 performs better but still has notable misclassifications into Class 1.\n\n>**Conclusion**:The model performs moderately well overall but struggles with:\n\n- Detecting Class 2 effectively.\n- Managing misclassifications between Class 1 and Class 2.\n\nImproving the dataset balance, refining the model, or employing techniques like class-specific weighting or advanced algorithms could enhance the performance.\n\n----\n\n>**Hyperparameter Tuning for MLP Classification**\n\nIn this section, we will perform hyperparameter tuning on our Multi-Layer Perceptron (MLP) model for classification tasks. The goal is to optimize the model's performance by systematically varying key hyperparameters, including the optimizer type, the number of neurons in hidden layers, the number of hidden layers, and the learning rate used in the optimization algorithm. By exploring different combinations of these hyperparameters, we aim to identify the configuration that yields the best classification accuracy and generalization capability on our dataset.\n\n>*Using different optimizers during minimization of the MSE loss function*\n\n In the initial stage, various optimizers were applied to the same network architecture. The performance metrics for the model with different optimizers are presented below.\n \n\n| Sl.No | Optimizer | Hidden Layers (L1, L2) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|-----------|------------------------|----------|-----------|--------|----------|------------------|\n| 1     | Adam      | 20, 10                 | 0.62     | 0.61      | 0.62   | 0.554    | Relatively Stable|\n| 2     | SGD       | 20, 10                 | 0.61     | 0.60      | 0.61   | 0.570    | Less Stable      |\n| 3     | Rmsprop   | 20, 10                 | 0.61     | 0.617     | 0.616  | 0.573    | Unstable         |\n| 4     | Adadelta  | 20, 10                 | 0.44     | 0.216     | 0.442  | 0.29     | Highly Unstable  |\n| 5     | Adagrad   | 20, 10                 | 0.61     | 0.62      | 0.61   | 0.55     | Unstable         |\n\nFrom the performance metrics, the MLP model with `Adam` optimizer is found to a better performer. For the next stage we fix `Adam` as the optimizer.\n\n>*Changing number of neurons in hidden layers*\n\nIn the next stage, we will vary the number of neurons in the hidden layers while keeping other hyperparameters constant. The performance metrics for the model with different configurations of neurons in the hidden layers will be analyzed to determine the optimal structure for our classification task.\n\n| Sl.No | Hidden Layers (L1, L2) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|------------------------|----------|-----------|--------|----------|------------------|\n| 1     | 30, 10                 | 0.60     | 0.605     | 0.69   | 0.558    | Less Stable      |\n| 2     | 15, 10                 | 0.61     | 0.644     | 0.644  | 0.605    | Less Stable      |\n| 3     | 20, 20                 | 0.621    | 0.621     | 0.614  | 0.605    | Relatively stable|\n| 4     | 20, 30                 | 0.61     | 0.590     | 0.610  | 0.599    | Highly Unstable  |\n\nFrom the performance matric, it is clear that MLP classifier with `Adam` optimizer and hidden layer size (20,20) is relatively a better one in the classification task. In the next stage let's fix the optimizer but add one more hidden layer.\n\n>*Adding More Hidden Layers*\n\nIn this stage of hyperparameter tuning, we will explore the impact of adding an additional hidden layer to our deep neural network (DNN) architecture. The objective is to determine how the inclusion of an extra hidden layer affects the model's performance metrics. By systematically varying the number of hidden layers, we aim to identify the optimal network depth that enhances the model's ability to learn complex patterns in the data while maintaining stability and generalization capability. The results of this experiment will provide insights into the trade-offs between model complexity and performance.\n\n| Sl.No | Hidden Layers (L1, L2,L3) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|---------------------------|----------|-----------|--------|----------|------------------|\n| 1     | 20, 20 ,10                | 0.623    | 0.611     | 0.623  | 0.609    | More Stable      |\n| 2     | 30, 20 ,10                | 0.616    | 0.611     | 0.611  | 0.612    | Less Stable      |\n| 3     | 20, 20 ,20                | 0.621    | 0.621     | 0.614  | 0.605    | Less stable      |\n| 4     | 20, 30 ,20                | 0.618    | 0.607     | 0.618  | 0.595    | Highly Unstable  |\n\nFrom, the table it is clear that MLP model with `Adam` optimizer, (20,20,10) hidden layer pattern is a relatively better stable classifier in this context.\n\n>*Fine Turning the Larning Rate*\n\nThe default learning rate for the `Adam` optimizer is set to 0.001. In this section, we will experiment with different learning rates to evaluate the performance metrics of the model. Specifically, we will test the model with learning rates of $\\eta = 0.001$, $\\eta = 0.01$, and $\\eta = 0.1$. Our findings indicate that increasing the learning rate beyond these values results in greater instability, as evidenced by higher variance across different iterations.\n\n| Sl.No | Layers (L1, L2, L3)  | Learning Rate($\\eta$) | Accuracy | Precision | Recall | F1-score | Status           |\n|-------|----------------------|-----------------------|----------|-----------|--------|----------|------------------|\n| 1     | 20, 20, 10           | 0.001                 |0.620     | 0.618     | 0.620  |  0.607   |    More Stable   |\n| 2     | 20, 20, 10           | 0.010                 |0.623     | 0.615     | 0.623  |  0.616   |         Stable   |\n| 3     | 20, 20, 10           | 0.100                 |0.609     | 0.488     | 0.609  |  0.534   |    Less Stable   |\n\n\n>*Interpretation and Conclusion*\n\nIn the context of this study, feature preprocessing is crucial to ensure both the ethical collection of data and the accuracy of the model. According to information from the UCI data repository, many features were derived from the killing of Abalones. To promote sustainability and avoid further harm to the Abalone population, our aim is to select only linearly independent features that can produce maximum accuracy without necessitating additional data collection through harmful means.\n\nFurthermore, a careful analysis of the data reveals no significant relationship between the feature values and the age of abalones. Therefore, instead of designing a model with age or the number of rings as the target variable, we categorize Abalones into three classes: infant, young, and adult (represented as Class 1, Class 2, and Class 3, respectively). This approach  simplifies the classification task, making it more practical and ethically responsible. By focusing on these categories, we aim to develop a robust model that can accurately classify the samples while adhering to ethical standards and promoting the conservation of the species.\n\nThe results indicate that the MLP classifier's performance on the Abalone dataset varies with different learning rates. With a learning rate of 0.001, the model achieves an accuracy of 0.620, precision of 0.618, recall of 0.620, and an F1-score of 0.607, and is considered more stable. Increasing the learning rate to 0.010 slightly improves the accuracy to 0.623, with a precision of 0.615, recall of 0.623, and an F1-score of 0.616, maintaining stability. However, further increasing the learning rate to 0.100 results in a decrease in performance, with an accuracy of 0.609, precision of 0.488, recall of 0.609, and an F1-score of 0.534, indicating less stability.\n\n\n\nIn conclusion, the MLP classifier with the Adam optimizer performs best (on an average) with a learning rate of 0.010, achieving the highest accuracy and maintaining stability. The results suggest that while the model is relatively stable with lower learning rates, higher learning rates lead to decreased performance and stability. Therefore, careful tuning of the learning rate is crucial for optimizing the performance of the MLP classifier on the Abalone dataset.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","embed-resources":true,"reference-location":"margin","toc":true,"toc-depth":3,"number-sections":true,"output-file":"evaluation1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","fontsize":"1.1em","theme":["pulse","html/styles.scss"],"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"title":"Assignment 1- Foundations of Deep Learning","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}